'use strict';

var tinyCookie = require('tiny-cookie');

/* eslint-disable no-console */
var enabled = false;

var log = function log() {
  var args = Array.prototype.slice.call(arguments);
  args[0] = Date.now() + ' feed.fm: ' + args[0];

  if (enabled) {
    console.log.apply(console, args);
  }

  var historyEntry;

  try {
    historyEntry = JSON.stringify({
      ts: new Date(),
      message: args[0],
      args: args.slice(1)
    });
  } catch (e) {
    historyEntry = JSON.stringify({
      ts: new Date(),
      message: args[0],
      args: 'truncated'
    });
  }

  log.history.push(historyEntry);

  if (history.length > 500) {
    log.history.shift();
  }
};

log.history = [];

log.enable = function () {
  enabled = true;
};

log.reset = function () {
  var oldHistory = log.history;
  log.history = [];
  return oldHistory;
};

function addProtocol(url, secure) {
  // handle '//somewhere.com/' url's
  if (url.slice(0, 2) === '//') {
    if (secure === true) {
      url = 'https:' + url;
    } else if (secure === false) {
      url = 'http:' + url;
    } else if (window.location.protocol.substr(0, 4) === 'http') {
      url = window.location.protocol + url;
    } else {
      url = 'http';
    }
  }

  return url;
}
/**
  * The below are adapted from the Underscore library:
  *     Underscore.js 1.5.2
  *     http://underscorejs.org
  *   (c) 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
  *   Underscore may be freely distributed under the MIT license.
  */

var idCounter = 0;
function uniqueId(prefix) {
  var id = ++idCounter;
  return prefix + id;
}
var nativeIndexOf = Array.prototype.indexOf;

function contains(obj, target) {
  if (obj === null) return false;
  if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;
  return obj.some(function (value) {
    return value === target;
  });
}

function uniq(array, isSorted, iterator, context) {
  if (typeof isSorted === 'function') {
    context = iterator;
    iterator = isSorted;
    isSorted = false;
  }

  var initial = iterator ? array.map(iterator, context) : array;
  var results = [];
  var seen = [];
  initial.forEach(function (value, index) {
    if (isSorted ? !index || seen[seen.length - 1] !== value : !contains(seen, value)) {
      seen.push(value);
      results.push(array[index]);
    }
  });
  return results;
}

function intersection(alpha, tests) {
  var retests = tests.map(function (test) {
    return new RegExp(test);
  });
  return uniq(alpha).filter(function (item) {
    return retests.find(function (other) {
      return other.test(item);
    });
  });
}
function once(func) {
  var ran = false,
      memo;
  return function () {
    if (ran) return memo;
    ran = true;
    memo = func.apply(this, arguments);
    func = null;
    return memo;
  };
}
function repeatAfter(delay, max, cb) {
  delay = delay ? 2 * delay : 200;

  if (delay > max) {
    delay = max;
  }

  setTimeout(function () {
    cb(delay);
  }, delay);
}

var baseUrl = 'https://feed.fm';
function getBaseUrl() {
  return baseUrl;
}
function setBaseUrl(url) {
  baseUrl = addProtocol(url);
}

var cookieName = 'cid';
var clientPromise;
var noDocument = typeof document === 'undefined';
var noDocumentClientId = null;

function _getStoredCid() {
  if (noDocument) {
    return noDocumentClientId;
  } else {
    return tinyCookie.getCookie(cookieName);
  }
}

function _setStoredCid(value) {
  if (noDocument) {
    noDocumentClientId = value;
  } else {
    tinyCookie.setCookie(cookieName, value, {
      expires: 3650,
      path: '/'
    });
  }
}

function _deleteStoredCid() {
  if (noDocument) {
    noDocumentClientId = null;
  } else {
    tinyCookie.removeCookie(cookieName);
  }
} // hit the server up for a client id and return it to the callback


function _requestClientId(onSuccess, delay) {
  // see if we've got a cookie
  var clientId = _getStoredCid();

  if (clientId) {
    return onSuccess(clientId);
  } else {
    fetch(getBaseUrl() + '/api/v2/client', {
      method: 'POST'
    }).then(function (response) {
      return response.json();
    }).then(function (response) {
      if (response.success) {
        onSuccess(response.client_id);
      } else {
        repeatAfter(delay, 2000, function (newDelay) {
          // retry until the end of time
          _requestClientId(onSuccess, newDelay);
        });
      }
    }).catch(function (response) {
      if (response.status === 403) {
        try {
          var fullResponse = JSON.parse(response.responseText);
          log('error trying to get client id:', fullResponse);
        } catch (e) {
          // some other response - fall through and try again
          log('unknown response for client id request', e.message);
        }
      } else {
        log('unknown client id response status', response.status);
      }

      repeatAfter(delay, 2000, function (newDelay) {
        // retry until the end of time
        _requestClientId(onSuccess, newDelay);
      });
    });
  }
}

function getClientId() {
  if (!clientPromise) {
    var localClientPromise = clientPromise = new Promise(function (resolve) {
      _requestClientId(function (clientId) {
        if (clientPromise === localClientPromise) {
          // success!
          _setStoredCid(clientId);

          resolve(clientId);
        } else if (clientPromise) {
          // end user updated the client id while we were waiting for a new one
          clientPromise.then(function (clientId) {
            resolve(clientId);
          });
        } else {
          // end user deleted the client id while we were waiting for a new one
          getClientId().then(function (clientId) {
            resolve(clientId);
          });
        }
      });
    });
  }

  return clientPromise;
}
var getStoredClientId = _getStoredCid;
var setStoredClientId = _setStoredCid;
function deleteClientId() {
  _deleteStoredCid();

  clientPromise = null;
}

function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}

function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
}

function _iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(n);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

function _createForOfIteratorHelper(o) {
  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) {
      var i = 0;

      var F = function () {};

      return {
        s: F,
        n: function () {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function (e) {
          throw e;
        },
        f: F
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var it,
      normalCompletion = true,
      didErr = false,
      err;
  return {
    s: function () {
      it = o[Symbol.iterator]();
    },
    n: function () {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function (e) {
      didErr = true;
      err = e;
    },
    f: function () {
      try {
        if (!normalCompletion && it.return != null) it.return();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}

var slice = Array.prototype.slice;
var Events = {
  // Bind an event to a `callback` function. Passing `"all"` will bind
  // the callback to all events fired.
  on: function on(name, callback, context) {
    if (!eventsApi(this, 'on', name, [callback, context]) || !callback) {
      return this;
    }

    if (!this._events) {
      this._events = {};
    }

    var events = this._events[name] || (this._events[name] = []);
    events.push({
      callback: callback,
      context: context,
      ctx: context || this
    });
    return this;
  },
  // Bind an event to only be triggered a single time. After the first time
  // the callback is invoked, it will be removed.
  once: function once$1(name, callback, context) {
    if (!eventsApi(this, 'once', name, [callback, context]) || !callback) {
      return this;
    }

    var self = this;
    var once$1 = once(function () {
      self.off(name, once$1);
      callback.apply(this, arguments);
    });
    once$1._callback = callback;
    return this.on(name, once$1, context);
  },
  // Remove one or many callbacks. If `context` is null, removes all
  // callbacks with that function. If `callback` is null, removes all
  // callbacks for the event. If `name` is null, removes all bound
  // callbacks for all events.
  off: function off(name, callback, context) {
    var retain, ev, events, names, i, l, j, k;

    if (!this._events || !eventsApi(this, 'off', name, [callback, context])) {
      return this;
    }

    if (!name && !callback && !context) {
      this._events = {};
      return this;
    }

    names = name ? [name] : Object.keys(this._events);

    for (i = 0, l = names.length; i < l; i++) {
      name = names[i];

      if (events = this._events[name]) {
        // eslint-disable-line no-cond-assign
        this._events[name] = retain = [];

        if (callback || context) {
          for (j = 0, k = events.length; j < k; j++) {
            ev = events[j];

            if (callback && callback !== ev.callback && callback !== ev.callback._callback || context && context !== ev.context) {
              retain.push(ev);
            }
          }
        }

        if (!retain.length) {
          delete this._events[name];
        }
      }
    }

    return this;
  },
  // Trigger one or many events, firing all bound callbacks. Callbacks are
  // passed the same arguments as `trigger` is, apart from the event name
  // (unless you're listening on `"all"`, which will cause your callback to
  // receive the true name of the event as the first argument).
  trigger: function trigger(name) {
    if (!this._events) {
      return this;
    }

    var args = slice.call(arguments, 1);

    if (!eventsApi(this, 'trigger', name, args)) {
      return this;
    }

    var events = this._events[name];
    var allEvents = this._events.all;

    if (events) {
      triggerEvents(events, args);
    }

    if (allEvents) {
      triggerEvents(allEvents, arguments);
    }

    return this;
  },
  // Tell this object to stop listening to either specific events ... or
  // to every object it's currently listening to.
  stopListening: function stopListening(obj, name, callback) {
    var listeners = this._listeners;

    if (!listeners) {
      return this;
    }

    var deleteListener = !name && !callback;

    if (_typeof(name) === 'object') {
      callback = this;
    }

    if (obj) {
      (listeners = {})[obj._listenerId] = obj;
    }
    /*jshint forin:false */


    for (var id in listeners) {
      listeners[id].off(name, callback, this);

      if (deleteListener) {
        delete this._listeners[id];
      }
    }

    return this;
  }
}; // Regular expression used to split event strings.

var eventSplitter = /\s+/; // Implement fancy features of the Events API such as multiple event
// names `"change blur"` and jQuery-style event maps `{change: action}`
// in terms of the existing API.

var eventsApi = function eventsApi(obj, action, name, rest) {
  if (!name) {
    return true;
  } // Handle event maps.


  if (_typeof(name) === 'object') {
    /*jshint forin:false */
    for (var key in name) {
      obj[action].apply(obj, [key, name[key]].concat(rest));
    }

    return false;
  } // Handle space separated event names.


  if (eventSplitter.test(name)) {
    var names = name.split(eventSplitter);

    for (var i = 0, l = names.length; i < l; i++) {
      obj[action].apply(obj, [names[i]].concat(rest));
    }

    return false;
  }

  return true;
}; // A difficult-to-believe, but optimized internal dispatch function for
// triggering events. Tries to keep the usual cases speedy (most internal
// Backbone events have 3 arguments).


var triggerEvents = function triggerEvents(events, args) {
  var ev,
      i = -1,
      l = events.length,
      a1 = args[0],
      a2 = args[1],
      a3 = args[2];

  switch (args.length) {
    case 0:
      while (++i < l) {
        (ev = events[i]).callback.call(ev.ctx);
      }

      return;

    case 1:
      while (++i < l) {
        (ev = events[i]).callback.call(ev.ctx, a1);
      }

      return;

    case 2:
      while (++i < l) {
        (ev = events[i]).callback.call(ev.ctx, a1, a2);
      }

      return;

    case 3:
      while (++i < l) {
        (ev = events[i]).callback.call(ev.ctx, a1, a2, a3);
      }

      return;

    default:
      while (++i < l) {
        (ev = events[i]).callback.apply(ev.ctx, args);
      }

  }
};

var listenMethods = {
  listenTo: 'on',
  listenToOnce: 'once'
}; // Inversion-of-control versions of `on` and `once`. Tell *this* object to
// listen to an event in another object ... keeping track of what it's
// listening to.

var _loop = function _loop() {
  var method = _Object$keys[_i];
  var implementation = listenMethods[method];

  Events[method] = function (obj, name, callback) {
    var listeners = this._listeners || (this._listeners = {});
    var id = obj._listenerId || (obj._listenerId = uniqueId('l'));
    listeners[id] = obj;

    if (_typeof(name) === 'object') {
      callback = this;
    }

    obj[implementation](name, callback, this);
    return this;
  };
};

for (var _i = 0, _Object$keys = Object.keys(listenMethods); _i < _Object$keys.length; _i++) {
  _loop();
}

/**
 * This class connects to a specific simulcast stream and
 * sends out events to indicate when new songs are starting
 * or when music has stopped playing. This listener has a
 * 'state' that is one of 
 * 
 *   'idle' - no music is playing
 *   'playing' - a song is actively playing
 *   'paused' - the current song is paused
 *   'music-unavailable' - no music is available for this client
 * 
 * events:
 *    play-started - indicates a new song has begun playback, or we've
 *        dropped in on an already playing song
 *    music-unavailable - indicates the listener may not listen to music
 *    music-stopped - indicates that music has stopped streaming. This maps
 *        up to the end of a broadcast, and not a 'pause' in music.
 *    state-changed - indicates the state of the player changed
 * 
 * demo: https://jsbin.com/biwogiyewu/edit?html,js,output
 */

var Listener = /*#__PURE__*/function () {
  function Listener(uuid) {
    _classCallCheck(this, Listener);

    Object.assign(this, Events);
    this._uuid = uuid;
    this._state = 'idle'; //this._activePlay = null;
  }

  _createClass(Listener, [{
    key: "listen",
    value: function listen() {
      var _this = this;

      if (this._timeout) {
        clearTimeout(this._timeout);
        delete this._timeout;
      }

      getClientId().then(function (clientId) {
        _this.onTimeout(clientId);
      });
    }
  }, {
    key: "stop",
    value: function stop() {
      if (this._timeout) {
        clearTimeout(this._timeout);
        delete this._timeout;
      }

      var previousState = this._state;
      this._state = 'idle';
      delete this._activePlay;

      if (previousState !== 'idle') {
        try {
          this.trigger('state-changed', this._state, previousState);
        } catch (e) {
          /* ignore */
        }
      }
    }
  }, {
    key: "onTimeout",
    value: function onTimeout(clientId) {
      var _this2 = this;

      fetch(getBaseUrl() + "/api/v2/simulcast/".concat(this._uuid, "/listen"), {
        method: 'POST',
        body: JSON.stringify({
          client_id: clientId
        }),
        headers: {
          'Content-Type': 'application/json'
        }
      }).then(function (response) {
        return response.json();
      }).then(function (response) {
        var delay = 5000;

        if (response.success) {
          var becameIdle = response.state === 'idle' && _this2._state !== 'idle';
          var previousPlay = _this2._activePlay;
          var previousState = _this2._state;
          var state = _this2._state = response.state;

          if (state === 'idle') {
            delete _this2._activePlay;
          } else {
            _this2._activePlay = response.play;
          }

          if (previousState !== state) {
            try {
              _this2.trigger('state-changed', state, previousState);
            } catch (e) {
              /* ignore */
            }
          }

          if (state === 'idle') {
            if (becameIdle) {
              try {
                _this2.trigger('music-stopped');
              } catch (e) {
                /* ignore */
              }
            }
          } else {
            if (!previousPlay || previousPlay.id !== _this2._activePlay.id) {
              try {
                _this2.trigger('play-started', _this2._activePlay);
              } catch (e) {
                /* ignore */
              }
            }

            if (response.seconds_since_start > 20 && response.play.duration_in_seconds - response.seconds_since_start > 20) {
              delay = 15000;
            }
          }
        } else {
          if (response.error && response.error.code === 19) {
            _this2._state = 'music-unavailable';

            _this2.trigger('music-unavailable'); // don't schedule another update


            return;
          }
        }

        _this2._timeout = setTimeout(function () {
          _this2.onTimeout(clientId);
        }, delay);
      }).catch(function (response) {
        if (response.status === 403) {
          try {
            var fullResponse = JSON.parse(response.responseText);

            if (fullResponse.error && fullResponse.error.code === 19) {
              try {
                _this2._state = 'music-unavailable';

                _this2.trigger('music-unavailable');
              } catch (e) {
                /* ignore */
              }

              return;
            }

            console.log('unexpected error:', fullResponse);
          } catch (e) {
            // some other response - fall through and try again
            console.log('bad response', e.message);
          }
        } else {
          console.log('odd response', response);
        }

        _this2._timeout = setTimeout(function () {
          _this2.onTimeout(clientId);
        }, 15000);
      });
    }
  }, {
    key: "getCurrentState",
    value: function getCurrentState() {
      return this._state;
    }
  }, {
    key: "getCurrentPlay",
    value: function getCurrentPlay() {
      return this._activePlay;
    }
  }]);

  return Listener;
}();

var FEED_STATE_KEY = 'feedfm:active';
var FEED_ELAPSED_TIME_KEY = 'feedfm:elapsed_time';

function supports_html5_storage() {
  try {
    return 'localStorage' in window && window['localStorage'] !== null;
  } catch (e) {
    return false;
  }
}

function store(key, value) {
  if (supports_html5_storage()) {
    localStorage.setItem(key, value);
  }
}

function remove(key) {
  if (supports_html5_storage()) {
    localStorage.removeItem(key);
  }
}

function get(key) {
  if (supports_html5_storage()) {
    return localStorage.getItem(key);
  } else {
    return null;
  }
}

function persistState(state) {
  var timestamp = Date.now();
  var asString = JSON.stringify({
    state: state,
    timestamp: timestamp
  });
  var stringTimestamp = Date.now(); // update timestamp and store in local storage

  store(FEED_STATE_KEY, asString);
  var stateTimestamp = Date.now();
  store(FEED_ELAPSED_TIME_KEY, '0');
  log('persisted state', {
    timestamp: timestamp,
    encodingTime: stringTimestamp - timestamp,
    storageTime: stateTimestamp - stringTimestamp,
    state: state
  });
}
function persistElapsed(milliseconds) {
  // save elapsed seconds in current song
  store(FEED_ELAPSED_TIME_KEY, milliseconds.toString());
}
function retrieveStateAndElapsed(maxAge) {
  // pull things out of state, if they're less than maxAge milliseconds old, or null
  var encoded = get(FEED_STATE_KEY);

  if (encoded) {
    var persisted = JSON.parse(encoded);

    if (persisted.timestamp + maxAge > Date.now()) {
      var elapsed = parseFloat(get(FEED_ELAPSED_TIME_KEY), 10);
      return [persisted.state, elapsed];
    }
  }

  return [];
}
function clearPersistance() {
  // nuke any stored state
  remove(FEED_STATE_KEY);
  remove(FEED_ELAPSED_TIME_KEY);
}

var version="1.103.1";

/*
 *  Feed Media Session API
 *
 *  This manages all communication with the server and is the single point
 *  of truth for a client to manage what is actively being played. It
 *  should be created with:
 *
 *  var session = new Feed.Session(token, secret[, options]);
 *
 *  Then you attach event listeners to the session:
 *
 *  session.on('play-active', someHandler);
 *
 *  Then you can optionally set a station:
 *
 *  session.setStationId(stationId);
 *
 *  If any of the above calls are made while we're actively tuning (we've
 *  got an active song or a pending song), then any currently active song
 *  will be marked as 'completed' and a new song will be requested from
 *  the server.
 *
 *  Then you tell the session to start maintaining a queue of 
 *  music to play:
 *
 *  session.tune();
 *
 *  The session will now emit the following events:
 *
 *  music-unavailable: if the current user may not listen to music
 *    This check is made every time we try to retrieve a song, and also
 *    on the 'tune()' call.  Once 
 *    you get this event, you should assume nothing further will work.
 *  invalid-credentials: the token and secret passed to this function
 *    are not valid.
 *  placement: after we tune in to a placement or station,
 *    this passes on information about the placement we
 *    tuned in to.
 *  stations: after tuning to a specific placement, the server returns a
 *    list of available stations. This is that list.
 *  station-changed: emitted after a 'setStation' call, and passed the
 *    ID of the station and the station object
 *  play-active: when the session has a play ready for playback
 *  play-started: when the active play has started playback (as
 *    a result of a call to reportPlayStarted)
 *  play-completed: when the session has successfully told the server
 *    that the current play has completed, been skipped (after a 
 *    call to reportPlayCompleted), or been invalidated
 *  skip-denied: when the session has been told by the server that the
 *    skip cannot be performed (after a call to requestSkip)
 *  plays-exhausted: when the server can find no more music in the
 *    current station that satisfies DMCA constraints (this will
 *    be either the first event after a 'tune' call, or after a
 *    play-completed event). The client must make another call to
 *    tune() to begin pulling in more music.
 *  prepare-sound: this holds a URL of a sound that might be played
 *    next. Clients can start loading the sound in preparation.
 *  forbidden: if an unsatisfiable request is made (such as to advance
 *   in a non-first play station)
 *
 *  Clients that use the session object should tell the session about
 *  the status of the current play as it progresses:
 *
 *  session.reportPlayStarted(): tell the server we have begun playback of the
 *    current song to the end user.
 *  session.reportPlayElapsed(seconds): tell the server how many elapsed seconds
 *    of the song have been played since it started.
 *  session.reportPlayCompleted(): tell the server that we have completed 
 *    playing the current song. This will cause the session object
 *    to emit a 'play-completed' event followed by a 'play-active' when
 *    the next song is ready for playback
 *
 *  session.requestSkip(): ask the server if we can skip playback of the current
 *    song. If the skip is denied, a 'skip-denied' event will be triggered,
 *    otherwise a 'play-completed' will be triggered.
 *  session.requestInvalidate(): tell the server that we're unable to play the
 *    current song for some reason, and the server should stop playback
 *    of the song (if started) and give us a new song. The session will
 *    trigger a 'play-completed' event after this call.
 *
 *  Data held by the session can be retrieved with:
 *
 *  session.getActivePlay(): returns the currently active play, if any, or null
 *  session.isTuned(): true if the session has active plays available or is awaiting
 *    plays from the server
 *  session.hasActivePlayStarted(): returns true if the active play is playing now
 *  session.canSkip(): returns true if there is a song being played now and 
 *    we believe we can skip it.
 *
 *  Other misc calls:
 *  
 *  session.likePlay(), session.unlikePlay(), session.dislikePlay(): like handling
 *  session.setFormats(formats): comma separated list of audio formats to 
 *                               request, i.e.: 'mp3', 'aac', 'aac,mp3'. Defaults to
 *                               'mp3,aac'
 *
 *  The optional 'options' argument passed to the constructor can have the following
 *  attributes:
 *    baseUrl: defines the base host that responds to API calls - defaults
 *       to '//feed.fm'. Really only used with local testing.
 *    simulcast: id of simulcast to broad
 */

var Session = function Session(token, secret, options) {
  Object.assign(this, Events); // No token/secret implies we're restoring from a saved state. It would
  // be best if this class could suspend/restore itself, but things are 
  // so poorly encapsulated now that it isn't worth putting the suspend/restore
  // in multiple places.

  if (!token || !secret) {
    return;
  }

  options = options || {};

  if (options.baseUrl) {
    setBaseUrl(options.baseUrl);
  }

  this.config = {
    remoteLogging: !!options.remoteLogging,
    // token
    // secret
    // placementId
    // placement
    // stationId
    // stations
    // station
    formats: 'mp3,aac',
    maxBitrate: 128,
    timeOffset: 0,
    // Represent the active 'play' or null if there is no active play. This should
    // only be null before the first tune() call or after the server tells us there
    // is no more music available.
    current: null,

    /* {
         play:  play object we're currently playing
         started: defaults to false
         canSkip: defaults to false
         retryCount: number of times we've tried to tell server we started this
        }, */
    // Details of any 'POST /play' request we're awaiting a response for. If this
    // is null, then we're not waiting for the server to give us a play
    pendingRequest: null,

    /* {
         url:        url being posted to
         ajax:       form data we sent to request a play, copied
                     here so we can retry it if it fails
         retryCount: number of times we've retried 
       }, */
    // Once a play has been created and then started, the server will let us
    // create a new play. This holds a reference to the next play that will
    // be active on completion of the current play
    pendingPlay: null // play object we'll start upon completion of current
    //   sound 

  };

  if (token && secret) {
    this.setCredentials(token, secret);
  }

  if (options.remoteLogging) {
    log('remote logging enabled', this.config);

    this._submitLogHistory();
  }
};

Session.prototype.setCredentials = function (token, secret) {
  this.config.token = token;
  this.config.secret = secret;
};

Session.prototype.setStationId = function (stationId, advance, secondsOfCrossfade) {
  // if we haven't received stations, we can't select one
  if (!this.config.stations) {
    return;
  }

  var stringStationId = '' + stationId;
  var changed = '' + this.config.stationId !== stringStationId;

  if (changed || advance) {
    var station = this.config.stations.find(function (station) {
      return '' + station.id === stringStationId;
    });

    if (station) {
      this.config.stationId = stationId;
      this.config.station = station;

      if (changed) {
        this.trigger('station-changed', stationId, station);
      } // abort any pending requests or plays


      this.config.pendingRequest = null;
      this.config.pendingPlay = null; // stop playback of any current song, and set
      // the status to waiting

      this._assignCurrentPlay(null, true); // request the next play


      this._requestNextPlay(0, advance, secondsOfCrossfade);
    }
  }
};

Session.prototype.setFormats = function (formats) {
  this.config.formats = formats; // re-retrieve the next song, since we changed formats

  if (this.isTuned()) {
    this.tune();
  }
};

Session.prototype.setMaxBitrate = function (maxBitrate) {
  this.config.maxBitrate = maxBitrate;
}; // tune


Session.prototype.tune = function () {
  if (!this.config.token) {
    throw new Error('no token set with setCredentials()');
  }

  if (!this.config.secret) {
    throw new Error('no secret set with setCredentials()');
  } // abort any pending requests or plays


  this.config.pendingRequest = null;
  this.config.pendingPlay = null; // stop playback of any current song, and set
  // the status to waiting

  this._assignCurrentPlay(null, true); // pull information in about the placement, followed by
  // a request for the next play


  this._getDefaultPlacementInformation();
}; // _getDefaultPlacementInformation


Session.prototype._getDefaultPlacementInformation = function (delay) {
  var self = this;

  if (this.config.placementId && this.config.placement && this.config.placement.id === this.config.placementId) {
    // already have placement info, so kick off request for next play
    this._requestNextPlay();

    return;
  } // request placement info from server


  log('requesting default placement information from server');

  self._signedAjax(getBaseUrl() + '/api/v2/session', {
    method: 'POST',
    body: JSON.stringify({
      client_id: getStoredClientId()
    }),
    headers: {
      'Content-Type': 'application/json'
    }
  }).then(function (response) {
    return response.json();
  }).then(function (response) {
    if (response.session && response.session.client_id) {
      setStoredClientId(response.session.client_id);
    } // client id creation now tied to session, so this next call is superfluous,
    // and only exists for testing


    return self._getClientId().then(function () {
      return response;
    });
  }).then(self._receiveDefaultPlacementInformation.bind(self)).catch(self._failedDefaultPlacementInformation.bind(self, delay));
};

Session.prototype._receiveDefaultPlacementInformation = function (placementInformation) {
  if (placementInformation && placementInformation.success && placementInformation.placement) {
    this.config.placement = placementInformation.placement;
    this.config.stations = placementInformation.stations;
    this.config.placementId = placementInformation.placement.id;
    this.trigger('placement', this.config.placement);

    if (this.config.stations.length > 0) {
      this.config.stationId = this.config.stations[0].id;
      this.config.station = this.config.stations[0];
      this.trigger('station-changed', this.config.stationId, this.config.station);
    }

    this.trigger('stations', this.config.stations); // kick off request for next play

    this._requestNextPlay();
  } else {
    // music is not available to this user for some reason.
    this.trigger('music-unavailable');
  }
};

Session.prototype._failedDefaultPlacementInformation = function (delay, response) {
  var _this = this;

  if (response.status === 401) {
    try {
      var fullResponse = JSON.parse(response.responseText);

      if (fullResponse.error && fullResponse.error.code === 5) {
        this.trigger('invalid-credentials');
        return;
      }
    } catch (e) {// ignore
    }
  } else {
    // eslint-disable-next-line no-console
    console.warn('error from placement request', response);
  } // otherwise, try again in a bit


  delay = delay ? delay * 2 : 500;
  setTimeout(function () {
    _this._getDefaultPlacementInformation(delay);
  }, delay);
};

Session.prototype.getActivePlacement = function () {
  if (this.config.placement) {
    return this.config.placement;
  } else {
    return null;
  }
};

Session.prototype.getActivePlay = function () {
  if (this.config.current) {
    return this.config.current.play;
  } else {
    return null;
  }
};

Session.prototype.isTuned = function () {
  return this.config.current || this.config.pendingRequest;
};

Session.prototype.hasActivePlayStarted = function () {
  return this.config.current && this.config.current.started;
};

Session.prototype.reportPlayStarted = function () {
  if (!this.config.current) {
    throw new Error('attempt to report a play started, but there is no active play');
  }

  this._startPlay(this.config.current.play);
};

Session.prototype.reportPlayElapsed = function (seconds) {
  if (!this.config.current) {
    throw new Error('attempt to report elapsed play time, but the play hasn\'t started');
  }

  this._signedAjax(getBaseUrl() + '/api/v2/play/' + this.config.current.play.id + '/elapse', {
    method: 'POST',
    body: JSON.stringify({
      seconds: seconds
    }),
    headers: {
      'Content-Type': 'application/json'
    }
  }).catch(function (e) {
    return log('server returned error on elapse call. ignoring', e);
  });
};

Session.prototype.reportPlayCompleted = function () {
  var self = this;

  if (this.config.current && this.config.current.started) {
    this._signedAjax(getBaseUrl() + '/api/v2/play/' + this.config.current.play.id + '/complete', {
      method: 'POST'
    }).then(function (response) {
      return response.json();
    }).catch(function (err) {
      log('play completed returned error - ignoring', err);
    }).finally(self._receivePlayCompleted.bind(self));
  } else {
    log('finish on non-active or playing song');
    throw new Error('no active or playing song');
  }
};

Session.prototype._receivePlayCompleted = function () {
  if (!this.config.pendingRequest) {
    log('song finished, and no outstanding request, so playing pendingPlay'); // if we're not waiting for an incoming request, then we must
    // have the next play queued up, so play it:

    var pendingPlay = this.config.pendingPlay;
    this.config.pendingPlay = null;

    this._assignCurrentPlay(pendingPlay);
  } else {
    log('song finished, but we\'re still waiting for next one to return'); // we're waiting for a request to come in, so kill the current
    // song and announce that we're waiting

    this._assignCurrentPlay(null, true);
  }
};

Session.prototype.reportPlayStopped = function (seconds) {
  if (this.config.current && this.config.current.started) {
    this._signedAjax(getBaseUrl() + '/api/v2/play/' + this.config.current.play.id + '/elapse', {
      method: 'POST',
      body: JSON.stringify({
        seconds: seconds
      }),
      headers: {
        'Content-Type': 'application/json'
      }
    }).then(function (response) {
      return response.json();
    }).catch(function (e) {
      return log('server returned error on elapse call. ignoring', e);
    });
  } // dump any future plays queued up


  this.config.pendingRequest = null;
  this.config.pendingPlay = null; // we're not playing anything now, baby!

  this._assignCurrentPlay(null, true);
};

Session.prototype.requestSkip = function () {
  var _this2 = this;

  if (!this.hasActivePlayStarted()) {
    throw new Error('No song playing or started');
  }

  if (!this.config.current.canSkip) {
    setTimeout(function () {
      _this2.trigger('skip-denied');
    }, 1);
    return;
  }

  this._signedAjax(getBaseUrl() + '/api/v2/play/' + this.config.current.play.id + '/skip', {
    method: 'POST'
  }).then(function (response) {
    return response.json();
  }).then(this._receiveSkip.bind(this, this.config.current.play)).catch(this._failSkip.bind(this, this.config.current.play));
};

Session.prototype.requestInvalidate = function (url) {
  if (!url) {
    if (!this.config.current) {
      throw new Error('No active song to invalidate!');
    }

    this._sendInvalidate(this.config.current.play);
  } else if (this.config.current && this.config.current.play.audio_file.url === url) {
    this._sendInvalidate(this.config.current.play);
  } else if (this.config.pendingPlay && this.config.pendingPlay.audio_file.url === url) {
    this._sendInvalidate(this.config.pendingPlay);
  }
};

Session.prototype._sendInvalidate = function (play, delay) {
  this._signedAjax(getBaseUrl() + '/api/v2/play/' + play.id + '/invalidate', {
    method: 'POST'
  }).then(function (response) {
    return response.json();
  }).then(this._receiveInvalidate.bind(this, play)).catch(this._failInvalidate.bind(this, delay, play));
};

Session.prototype._failInvalidate = function (delay, play, response) {
  var self = this;
  delay = delay ? delay * 2 : 200;

  if (delay < 3000) {
    setTimeout(function () {
      self._sendInvalidate(play);
    }, delay);
  } else {
    log('gave up trying to invalidate play', response);
  }
};

Session.prototype._receiveInvalidate = function (play, response) {
  var self = this;
  log('invalidate response');

  this._submitLogHistory();

  setTimeout(function () {
    log('5 second follow up after invalidate');

    self._submitLogHistory();
  }, 5000);

  if (!response.success) {
    log('failed invalidate! - technically this is impossible');
    return;
  }

  if (!this.config.current || this.config.current.play !== play) {
    if (play === this.config.pendingPlay) {
      log('invalidated pending play, queueing up new pending play');
      this.config.pendingPlay = null;

      this._requestNextPlay();
    }

    return;
  }

  if (this.config.pendingPlay) {
    log('invalidating to song already queued up'); // skip to play already queued up

    var pendingPlay = this.config.pendingPlay;
    this.config.pendingPlay = null;

    this._assignCurrentPlay(pendingPlay);
  } else {
    log('invalidating current song');

    this._assignCurrentPlay(null, true);

    if (!this.config.pendingRequest) {
      log('queueing up new song');

      this._requestNextPlay();
    }
  }
};

Session.prototype._failSkip = function (play) {
  if (!this.config.current || this.config.current.play !== play) {
    // not playing this song any more - just ignore it
    return;
  } // technically the skip wasn't denied - we just couldn't confirm wether
  // it was ok, but this is the best we can return at the moment


  this.trigger('skip-denied');
};

Session.prototype._receiveSkip = function (play, response) {
  if (!this.config.current || this.config.current.play !== play) {
    // not playing this song any more - just ignore it
    return;
  }

  if (!response.success) {
    log('failed skip!');
    this.trigger('skip-denied');
    return;
  }

  if (this.config.pendingPlay) {
    log('skipping to song already queued up'); // skip to play already queued up

    var pendingPlay = this.config.pendingPlay;
    this.config.pendingPlay = null;

    this._assignCurrentPlay(pendingPlay);
  } else if (this.config.pendingRequest) {
    log('skipping to what is queued up'); // we're waiting for a request - so just wait for that to show up

    this._assignCurrentPlay(null, true);
  } else {
    log('skipping to what is queued up'); // nothing queued up and nothing being requested - we're outta music!

    this._assignCurrentPlay(null);
  }
};

Session.prototype._startPlay = function (play) {
  if (this.config.current.retryCount > 2) {
    // fuck it - let the user hear the song
    this._receiveStartPlay(play, {
      success: true,
      can_skip: true
    });
  } else {
    log('telling server we\'re starting the play', play); // tell the server that we're going to start this song

    this._signedAjax(getBaseUrl() + '/api/v2/play/' + play.id + '/start', {
      method: 'POST' // TODO: add timeout!

    }).then(function (response) {
      return response.json();
    }).then(this._receiveStartPlay.bind(this, play)).catch(this._failStartPlay.bind(this, play));
  }
};

Session.prototype._receiveStartPlay = function (play, response) {
  if (response.success) {
    if (this.config.current && this.config.current.play === play) {
      this.config.current.canSkip = response.can_skip;
      this.config.current.started = true; // since we're ok to start this song, we can start looking for the
      // next song

      this._requestNextPlay();

      this.trigger('play-started', play);
    } else {
      log('received start play, but not waiting any more');
    }
  } else {
    log('received failed start success');
  }
};

Session.prototype._failStartPlay = function (play, response) {
  var _this3 = this;

  var self = this;
  log('start failed', response);

  this._submitLogHistory();

  setTimeout(function () {
    log('5 second follow up after start failure');

    self._submitLogHistory();
  }, 5000); // only process if we're still actually waiting for this

  if (this.config.current && this.config.current.play === play) {
    if (response && response.status === 403) {
      try {
        var fullResponse = JSON.parse(response.responseText);

        if (fullResponse.error && fullResponse.error.code === 20) {
          // we seem to have missed the response to the original start, so
          // let's assume the start was good and the song is skippable
          return this._receiveStartPlay(play, {
            success: true,
            can_skip: true
          });
        }
      } catch (e) {
        // ignore
        log('unable to parse start play response', e.message);
      }
    }

    log('request failed - trying again in 1 second', response);
    this.config.current.retryCount++; // wait a second and try again

    setTimeout(function () {
      _this3._startPlay(play);
    });
  } else {
    log('startPlay failed, but we don\'t care any more');
  }
}; // start playing the given song


Session.prototype._assignCurrentPlay = function (play, waitingIfEmpty) {
  // remove any existing play
  if (this.config.current) {
    var currentPlay = this.config.current.play;
    this.config.current = null;
    this.trigger('play-completed', currentPlay);
  }

  if (play === null) {
    // nothing to play right now
    if (waitingIfEmpty) {
      //this.config.status = 'waiting';
      log('nothing to play... waiting');
    } else {
      //this.config.status = 'idle';
      log('nothing to play from the current station');
      this.trigger('plays-exhausted');
    }
  } else {
    // we're starting this song, so note that
    this.config.current = {
      play: play,
      canSkip: false,
      started: false,
      retryCount: 0
    }; //this.config.status = 'active';

    log('activated new song');
    this.trigger('play-active', play);
  }
};

Session.prototype._requestNextPlay = function (delay, advance, secondsOfCrossfade) {
  var self = this;

  self._getClientId().then(function (clientId) {
    if (self.config.pendingRequest) {
      if (!delay) {
        log('already waiting for a request to finish');
        return;
      } else if (delay > 60000) {
        log('giving up on retrieving next play'); // we already retried this - let's give up

        self.config.pendingRequest = null;

        if (self.config.current === null) {
          // we're not playing anything, so we're waiting. 
          // set assign play to null again to trigger empty/idle
          self._assignCurrentPlay(null);
        }

        return;
      } else {
        log('retrying pending request'); // retry the request

        self.config.pendingRequest.retryCount++;
        var _ajax = self.config.pendingRequest.ajax;

        self._signedAjax(self.config.pendingRequest.url, _ajax).then(function (response) {
          return response.json();
        }).then(self._receiveNextPlay.bind(self, _ajax)).catch(self._failedNextPlay.bind(self, delay, _ajax));

        return;
      }
    } else {
      // create a new request
      var data = {
        formats: self.config.formats,
        client_id: clientId,
        max_bitrate: self.config.maxBitrate,
        secure: true
      };

      if (self.config.placementId) {
        data.placement_id = self.config.placementId;
      }

      if (self.config.stationId) {
        data.station_id = self.config.stationId;
      }

      if (advance) {
        data.at = advance;

        if (secondsOfCrossfade) {
          data.crossfade = secondsOfCrossfade;
        }
      }

      var ajax = {
        method: 'POST',
        body: JSON.stringify(data),
        headers: {
          'Content-Type': 'application/json'
        }
      };
      self.config.pendingRequest = {
        url: getBaseUrl() + '/api/v2/play',
        ajax: ajax,
        retryCount: 0
      }; // request new play from server

      log('requesting new play from server', ajax);

      self._signedAjax(getBaseUrl() + '/api/v2/play', ajax).then(function (response) {
        return response.json();
      }).then(self._receiveNextPlay.bind(self, ajax)).catch(self._failedNextPlay.bind(self, delay, ajax));
    }
  });
}; // we received a song to play from the server


Session.prototype._receiveNextPlay = function (ajax, response) {
  // only process if we're still actually waiting for this
  if (this.config.pendingRequest && this.config.pendingRequest.ajax === ajax) {
    // this isn't pending any more
    this.config.pendingRequest = null;

    if (response.success) {
      this.trigger('prepare-sound', response.play.audio_file.url, response.play.start_at, response.play.id);

      if (this.config.current) {
        log('received play, but we\'re already playing, so queueing up', response.play); // play this when the current song is complete

        this.config.pendingPlay = response.play;
      } else {
        log('received play and no current song, making active now', response.play); // start playing this right now, since nothing else is playing

        this._assignCurrentPlay(response.play);
      }
    } else if (response.error && response.error.code === 9) {
      if (this.config.current) {
        log('ran out of music to play, but we\'re already playing');
        this.config.pendingPlay = null;
      } else {
        log('ran out of music, and nothing playing now');
        this.trigger('plays-exhausted');
      }
    } else if (response.error && response.error.code === 6) {
      this.trigger('forbidden', response.error.message);
    } else {
      log('unsuccessful response', response);
    }
  } else {
    log('nextPlay succeeded, but we don\'t care');
  }
}; // server returned an error when we requested the next song


Session.prototype._failedNextPlay = function (delay, ajax, response) {
  var _this4 = this;

  log('next play failed', response);

  this._submitLogHistory();

  setTimeout(function () {
    log('5 second follow up after next play failure');

    _this4._submitLogHistory();
  }, 5000); // only process if we're still actually waiting for this

  if (this.config.pendingRequest && this.config.pendingRequest.ajax === ajax) {
    if (response && response.status === 403) {
      try {
        var fullResponse = JSON.parse(response.responseText);

        if (fullResponse.error && fullResponse.error.code === 19) {
          // user isn't in the US any more, so let the call fail
          this.trigger('music-unavailable', fullResponse.error.message); // legacy:

          this.trigger('not-in-us', fullResponse.error.message);
          return;
        }
      } catch (e) {
        // some other response - fall through and try again
        log('problem parsing 403 response', e.message);
      }
    }

    delay = Math.min(delay ? delay * 2 : 500, 2000);
    log('request failed - trying again after ' + delay + 'ms');
    setTimeout(function () {
      _this4._requestNextPlay(delay);
    }, delay);
  } else {
    log('nextPlay failed, but we don\'t care');
  }
};

Session.prototype.canSkipInStation = function () {
  return !(this.config.station && this.config.station.can_skip === false);
};
/**
 * @returns {boolean} true if the user can skip the current song
 */


Session.prototype.maybeCanSkip = function () {
  return this.canSkip();
};
/**
 * @returns {boolean} true if the user can skip the current song
 */


Session.prototype.canSkip = function () {
  // you can probably skip unless we've explicitly disallowed it at the station or current song level
  var can = this.canSkipInStation() && this.config.current && this.config.current.started && this.config.current.canSkip;
  return !!can;
};
/**
 * @returns {boolean} true if the user can like the current song
 */


Session.prototype.canLike = function () {
  var response = !(this.config.station && this.config.station.can_like === false);
  return response;
};

Session.prototype.likePlay = function (playId) {
  if (!this.canLike()) {
    // technically, this play could be from a different station, but we're not tracking
    // that right now... so let's just assume it is in the current station.
    return;
  }

  this._signedAjax(getBaseUrl() + '/api/v2/play/' + playId + '/like', {
    method: 'POST'
  }).then(function (response) {
    return response.json();
  }).catch(function (e) {
    return log('server returned error on like call. ignoring', e);
  });

  if (this.config.current && this.config.current.play.id === playId) {
    this.config.current.play.liked = true;
  }
};

Session.prototype.unlikePlay = function (playId) {
  if (!this.canLike()) {
    // technically, this play could be from a different station, but we're not tracking
    // that right now... so let's just assume it is in the current station.
    return;
  }

  this._signedAjax(getBaseUrl() + '/api/v2/play/' + playId + '/like', {
    method: 'DELETE'
  }).then(function (response) {
    return response.json();
  }).catch(function (e) {
    return log('server returned error on unlike call. ignoring', e);
  });

  if (this.config.current && this.config.current.play.id === playId) {
    delete this.config.current.play['liked'];
  }
};

Session.prototype.dislikePlay = function (playId) {
  if (!this.canLike()) {
    // technically, this play could be from a different station, but we're not tracking
    // that right now... so let's just assume it is in the current station.
    return;
  }

  this._signedAjax(getBaseUrl() + '/api/v2/play/' + playId + '/dislike', {
    method: 'POST'
  }).then(function (response) {
    return response.json();
  }).catch(function (e) {
    return log('server returned error on invalidate call. ignoring', e);
  });

  if (this.config.current && this.config.current.play.id === playId) {
    this.config.current.play.liked = false;
  }
};

var cookieName$1 = 'cid';

Session.prototype._getStoredCid = function () {
  return tinyCookie.getCookie(cookieName$1);
};

Session.prototype._setStoredCid = function (value) {
  tinyCookie.setCookie(cookieName$1, value, {
    expires: 3650,
    path: '/'
  });
};

Session.prototype._deleteStoredCid = function () {
  tinyCookie.removeCookie(cookieName$1);
};

Session.prototype._sign = function (request) {
  var authorization;

  if (!request) {
    request = {};
  } // use Basic auth for HTTPS


  authorization = 'Basic ' + btoa(this.config.token + ':' + this.config.secret);

  if (request.headers) {
    request.headers['Authorization'] = authorization;
  } else {
    request.headers = {
      Authorization: authorization
    };
  }

  request.headers['X-Feed-SDK'] = version + ' js';

  if (this.extraHeaders) {
    for (var header in this.extraHeaders) {
      // eslint-disable-next-line
      if (this.extraHeaders.hasOwnProperty(header)) {
        request.headers[header] = this.extraHeaders[header];
      }
    }
  }

  return request;
};

Session.prototype._signedAjax = function (url, request) {
  var self = this;
  return self._ajax(url, self._sign(request)).then(function (response) {
    if (!response.ok) {
      throw new Error('server returned error ' + response.status + ': ' + response.statusText);
    }

    return response;
  });
};

Session.prototype._ajax = function (url, request) {
  return fetch(url, request);
};

Session.prototype._submitLogHistory = function () {
  var count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  var session = this;
  var history = log.history;
  log.history = [];

  if (!this.config.remoteLogging) {
    return;
  }

  return this._signedAjax(getBaseUrl() + '/api/v2/session/event', {
    method: 'POST',
    body: JSON.stringify({
      event: 'playerHistory',
      parameters: history
    }),
    headers: {
      'Content-Type': 'application/json'
    }
  }).then(function (response) {
    return response.json();
  }).catch(function () {
    if (count < 2) {
      setTimeout(function () {
        log.history = history.concat(['failed log report attempt, try #' + count], log.history);

        session._submitLogHistory(count + 1);
      }, 5000);
    }
  });
};

Session.prototype._submitLogHistory = function () {
  var count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  var session = this;
  var history = log.history;
  log.history = [];

  if (!this.config.remoteLogging) {
    return;
  }

  return this._signedAjax(getBaseUrl() + '/api/v2/session/event', {
    method: 'POST',
    body: JSON.stringify({
      event: 'playerHistory',
      parameters: history
    }),
    headers: {
      'Content-Type': 'application/json'
    }
  }).catch(function () {
    if (count < 2) {
      setTimeout(function () {
        log.history = history.concat(['failed log report attempt, try #' + count], log.history);

        session._submitLogHistory(count + 1);
      }, 5000);
    }
  });
};

Session.prototype._submitEvent = function (name, parameters) {
  var _this5 = this;

  var count = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  var session = this;
  return this._getClientId().then(function (clientId) {
    return _this5._signedAjax(getBaseUrl() + '/api/v2/session/event', {
      method: 'POST',
      body: JSON.stringify({
        event: name,
        client_id: clientId,
        parameters: JSON.stringify(parameters)
      }),
      headers: {
        'Content-Type': 'application/json'
      }
    });
  }).catch(function () {
    if (count < 2) {
      setTimeout(function () {
        log.history = history.concat(['failed event submission, try #' + count], log.history);

        session._submitLogHistory(count + 1);
      }, 5000);
    }
  });
};

Session.prototype._getClientId = function () {
  return getClientId();
};

/**
 * Test to see if browser supports blob URLs
 * 
 * adapted from https://github.com/ssorallen/blob-feature-check/blob/master/blob-feature-check.js
 **/
var blobSupport = false;

function fixBinary(bin) {
  var length = bin.length;
  var buf = new ArrayBuffer(length);
  var arr = new Uint8Array(buf);

  for (var i = 0; i < length; i++) {
    arr[i] = bin.charCodeAt(i);
  }

  return buf;
}

var binary = fixBinary(atob('iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAAAAAA6fptVAAAACklEQVR4nGP6DwABBQECz6AuzQAAAABJRU5ErkJggg=='));
var png = new Blob([binary], {
  type: 'image/png'
});

try {
  if (URL && URL.createObjectURL) {
    var objectUrl = URL.createObjectURL(png);

    if (/^blob:/.exec(objectUrl) !== null) {
      var img = new Image();

      img.onload = function () {
        blobSupport = true;
        URL.revokeObjectURL(objectUrl);
      };

      img.onerror = function () {
        blobSupport = false;
      };

      img.src = objectUrl;
    }
  }
} catch (e) {
  /* ignore - no blob support */
}

var hasBlobSupport = (function () {
  return blobSupport;
});

var DEFAULT_VOLUME = 1.0;
var IOS = ['iPad Simulator', 'iPhone Simulator', 'iPod Simulator', 'iPad', 'iPhone', 'iPod'].includes(navigator.platform) // iPad on iOS 13 detection
|| navigator.userAgent.includes('Mac') && 'ontouchend' in document;
var brokenWebkit = IOS && /OS 13_[543210]/i.test(navigator.userAgent);
var SILENCE = IOS ? 'https://u9e9h7z5.map2.ssl.hwcdn.net/feedfm-audio/250-milliseconds-of-silence.mp3' : 'data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA'; //const SILENCE = 'https://dgase5ckewowv.cloudfront.net/feedfm-audio/1573592316-88123.m4a';

var Sound = function Sound(speaker, options, id, url) {
  var obj = Object.assign(this, Events);
  obj.id = id; //url = url.replace('u9e9h7z5.map2.ssl.hwcdn.net', 's3.amazonaws.com');

  obj.url = url;
  obj.speaker = speaker;
  obj.loaded = false;

  if (options) {
    this.startPosition = +options.startPosition;
    this.endPosition = +options.endPosition;
    this.fadeInSeconds = +options.fadeInSeconds;

    if (this.fadeInSeconds) {
      this.fadeInStart = this.startPosition ? this.startPosition / 1000 : 0;
      this.fadeInEnd = this.fadeInStart + this.fadeInSeconds;
    } else {
      this.fadeInStart = 0;
      this.fadeInEnd = 0;
    }

    this.fadeOutSeconds = +options.fadeOutSeconds;

    if (this.fadeOutSeconds) {
      if (this.endPosition) {
        this.fadeOutStart = this.endPosition / 1000 - this.fadeOutSeconds;
        this.fadeOutEnd = this.endPosition / 1000;
      } else {
        this.fadeOutStart = 0;
        this.fadeOutEnd = 0;
      }
    }

    for (var _i = 0, _arr = ['play', 'pause', 'finish', 'elapse']; _i < _arr.length; _i++) {
      var ev = _arr[_i];

      if (ev in options) {
        obj.on(ev, options[ev]);
      }
    }

    this.gain = options.gain || 0;
  } else {
    this.gain = 0;
  }

  return obj;
};

function d(audio) {
  return ' src = ' + audio.src + ', time = ' + audio.currentTime + ', paused = ' + audio.paused + ', duration = ' + audio.duration + ', readyState = ' + audio.readyState;
}

Sound.prototype = {
  play: function play() {
    log('sound ' + this.id + ' play');
    return this.speaker._playSound(this);
  },
  // pause playback of the current sound clip
  pause: function pause() {
    log('sound ' + this.id + ' pause');
    return this.speaker._pauseSound(this);
  },
  // resume playback of the current sound clip
  resume: function resume() {
    log('sound ' + this.id + ' resume');
    return this.speaker._playSound(this);
  },
  // elapsed number of milliseconds played
  position: function position() {
    //log(this.id + ' sound position');
    return this.speaker._position(this);
  },
  // duration in milliseconds of the song
  // (this may change until the song is full loaded)
  duration: function duration() {
    //log(this.id + ' sound duration');
    return this.speaker._duration(this);
  },
  // stop playing the given sound clip, unload it, and disable events
  // note that no further events will be sent from this sound
  // (so no 'finish' event, in particular)
  destroy: function destroy(fadeOut) {
    log('sound ' + this.id + ' destroy' + (fadeOut ? ' (with fade)' : ''));

    this.speaker._destroySound(this, fadeOut);
  },
  gainAdjustedVolume: function gainAdjustedVolume(volume) {
    if (!this.gain) {
      return volume / 100;
    }

    var adjusted = Math.max(Math.min(volume / 100 * (50 * Math.pow(10, this.gain / 20)), 100), 0) / 100; //log('gain adjustment is ' + this.gain + ', and final adjusted volume is ' + adjusted);

    return adjusted;
  }
};
/**
 * Create new speaker object. Add event handling to it.
 * 
 * @returns Speaker
 */

var Speaker = function Speaker(options) {
  if (options && options.maxRetries) {
    this.maxRetries = options.maxRetries;
  }

  return Object.assign(this, Events);
}; // exports with this version of Javacript isn't working, so...


Speaker.IOS = IOS;
Speaker.brokenWebkit = brokenWebkit;

function createAudioContext() {
  var AudioCtor = window.AudioContext || window.webkitAudioContext;
  var desiredSampleRate = 44100;
  var context = new AudioCtor(); // Check if hack is necessary. Only occurs in iOS6+ devices
  // and only when you first boot the iPhone, or play a audio/video
  // with a different sample rate

  if (context.sampleRate !== desiredSampleRate) {
    var buffer = context.createBuffer(1, 1, desiredSampleRate);
    var dummy = context.createBufferSource();
    dummy.buffer = buffer;
    dummy.connect(context.destination);
    dummy.start(0);
    dummy.disconnect();
    context.close(); // dispose old context

    context = new AudioCtor();
  } //  despite being in the moz docs, this doesn't work:
  //  if (context.state !== 'running') {
  //    throw new Error('Initial playback was not started in response to a user interaction!', context.state);
  //  }


  return context;
}

Speaker.prototype = {
  vol: 100,
  // 0..100
  outstandingSounds: {},
  // Sound instances that have not yet been destroyed
  audioContext: null,
  // for mobile safari volume adjustment
  active: null,
  // active audio element, sound, and gain node
  fading: null,
  // fading audio element, sound, and gain node
  preparing: null,
  // preparing audio element, sound, and gain node
  responses: null,
  // array of response headers from preloading
  maxRetries: 10,
  // max number of times to retry preloading a song
  // each of the above look like:
  // {
  //   audio: an HTML Audio element (created during initializeAudio() and reused)
  //   sound: refers to Sound object whose URL has been assigned to 'audio.src' and
  //          audio.play() has successfully returned.
  //   gain: AudioGainNode for apple
  //   volume: relative volume of this sound (0..1),
  //   canplaythrough: boolean indicating if the 'canplaythrough' event has been
  //         triggered for this URL
  // }
  //
  // note that when audio.src is not SILENCE, and sound is null, we're waiting for
  // a return from audio.play(). If the audio.src is changed, or audio.pause() is called
  // before audio.play() returns, chrome will throw an error!
  //
  // When a sound is started, it is thrown into preparing.audio.src, then 'preparing' and
  // 'active' are swapped, then active.audio.play() is called.
  //
  // When a sound has completed playback or been destroyed, the sound property is set
  // to null, the audio is paused, and audio.src is set to SILENCE.
  // If the browser supports URL.objectToURL(), we try to load audio with fetch and
  // then pass the blob URL to the audio element.
  preloaded: null,

  /*
  { 
    url,             // url we are trying to load manually (will not be null)
    blobUrl: null  // blob url for URL above, or null if not loaded yet
  },
  */
  // Fallback for preloading if the browser does not support URL.objectToURL()
  prepareWhenReady: null,
  // { url, start }
  initializeAudio: function initializeAudio() {
    // On mobile devices, we need to kick off playback of a sound in
    // response to a user event. This does that.
    if (this.active === null) {
      log('initializing for mobile');

      try {
        throw new Error('initialize check');
      } catch (e) {
        log('initialize audio called from', e);
      }

      this.audioContext = createAudioContext();
      this.active = this._createAudio(SILENCE);
      this.fading = this._createAudio(SILENCE);
      var pwr = this.prepareWhenReady;

      if (pwr) {
        this.preparing = this._createAudio(pwr.url);

        this._prepare(pwr.url, pwr.startPosition);
      } else {
        this.preparing = this._createAudio(SILENCE);
      }
    } else {
      log('mobile already initialized');
    }
  },
  getSupportedFormats: function getSupportedFormats() {
    if (document.createElement('audio').canPlayType('audio/aac')) {
      return 'mp3,aac';
    } else {
      return 'mp3';
    }
  },
  _createAudioGainNode: function _createAudioGainNode(audio) {
    var source = this.audioContext.createMediaElementSource(audio);
    var gainNode = this.audioContext.createGain();
    gainNode.gain.value = DEFAULT_VOLUME;
    source.connect(gainNode);
    gainNode.connect(this.audioContext.destination);
    return gainNode.gain;
  },
  _createAudio: function _createAudio(url) {
    var DEFAULT_VOLUME = 1.0;
    var audio = new Audio(url);
    audio.crossOrigin = 'anonymous';
    audio.loop = false;
    audio.preload = 'auto';
    audio.volume = DEFAULT_VOLUME;

    this._addEventListeners(audio); // apple volume adjustment


    var gain = null;

    if (Speaker.IOS && !brokenWebkit) {
      gain = this._createAudioGainNode(audio);
    }

    return {
      audio: audio,
      sound: null,
      gain: gain,
      volume: DEFAULT_VOLUME,
      canplaythrough: false
    };
  },
  _addEventListeners: function _addEventListeners(audio) {
    audio.addEventListener('pause', this._onAudioPauseEvent.bind(this));
    audio.addEventListener('ended', this._onAudioEndedEvent.bind(this));
    audio.addEventListener('error', this._onAudioErroredEvent.bind(this));
    audio.addEventListener('timeupdate', this._onAudioTimeUpdateEvent.bind(this));
    audio.addEventListener('canplaythrough', this._onAudioCanPlay.bind(this));
    audio.addEventListener('canplay', function (event) {
      log('can play!', event.currentTarget.src);
    }); //this._debugAudioObject(audio);
  },
  _onAudioCanPlay: function _onAudioCanPlay(event) {
    var audio = event.currentTarget;

    if (audio.src === SILENCE) {
      return;
    }

    log('can play through!', audio.src);

    if (audio === this.preparing.audio) {
      log('preparing file can play through', audio.src);
      this.preparing.canplaythrough = true;
      this.trigger('prepared', audio.src, true);
    }
  },
  _onAudioPauseEvent: function _onAudioPauseEvent(event) {
    var audio = event.currentTarget;

    if (audio.src === SILENCE) {
      return;
    }

    if (audio !== this.active.audio || audio.currentTime === audio.duration) {
      return;
    }

    if (!this.active.sound) {
      log('active audio pause, but no matching sound');
      return;
    }

    this.active.sound.trigger('pause');
  },
  _onAudioEndedEvent: function _onAudioEndedEvent(event) {
    var audio = event.currentTarget;

    if (audio.src === SILENCE) {
      return;
    }

    if (audio === this.fading.audio) {
      revoke(audio);
      audio.src = SILENCE;
      this.fading.sound = null;
      return;
    }

    if (audio !== this.active.audio) {
      return;
    }

    if (!this.active.sound) {
      log('active audio ended, but no matching sound', audio.src);
      return;
    }

    log('active audio ended');
    var sound = this.active.sound;
    this.active.sound = null;
    sound.trigger('finish');
  },
  _onAudioErroredEvent: function _onAudioErroredEvent(event) {
    var audio = event.currentTarget;

    if (audio.src === SILENCE) {
      return;
    }

    if (audio === this.fading.audio) {
      revoke(audio);
      audio.src = SILENCE;
      this.fading.sound = null;
      return;
    }

    if (audio !== this.active.audio) {
      return;
    }

    if (!this.active.sound) {
      log('active audio errored, but no matching sound', audio.src);
      return;
    }

    log('active audio errored', event.error);
    var sound = this.active.sound;
    this.active.sound = null;
    sound.trigger('finish', event.error);
  },
  _onAudioTimeUpdateEvent: function _onAudioTimeUpdateEvent(event) {
    var audio = event.currentTarget;

    if (audio.src === SILENCE) {
      return;
    }

    if (audio === this.fading.audio && this.fading.sound) {
      if (this.fading.sound.endPosition && audio.currentTime >= this.fading.sound.endPosition / 1000) {
        this.fading.sound = null;
        revoke(this.fading.audio);
        this.fading.audio.src = SILENCE;
      } else {
        this._setVolume(this.fading);
      }

      return;
    }

    if (audio !== this.active.audio) {
      return;
    }

    if (!this.active.sound || this.active.sound.awaitingPlayResponse) {
      // got an elapse event before the play() succeeded
      return;
    }

    if (this.active.sound.endPosition && this.active.sound.endPosition / 1000 <= audio.currentTime) {
      // song reached end of play
      var sound = this.active.sound;
      this.active.sound = null;
      revoke(this.active.audio);
      this.active.audio.src = SILENCE;
      sound.trigger('finish');
    } else if (this.active.sound.fadeOutEnd && audio.currentTime >= this.active.sound.fadeOutStart) {
      // song hit start of fade out
      this._setVolume(this.active); // active becomes fading, and fading becomes active


      var fading = this.fading;
      this.fading = this.active;
      this.active = fading;
      this.active.sound = null; // not used any more
      // pretend the song finished

      this.fading.sound.trigger('finish');
    } else {
      this._setVolume(this.active);

      this.active.sound.trigger('elapse');
    }

    if (this.prepareWhenReady) {
      // we've got something we want to load. check if we've loaded 
      // enough of the current song that we can start loading next song.
      this.prepare(this.prepareWhenReady.url, this.prepareWhenReady.startPosition);
    }
  },
  _setVolume: function _setVolume(audioGroup, sound) {
    if (!sound) {
      sound = audioGroup.sound;
    }

    var currentTime = audioGroup.audio.currentTime;
    var currentVolume = audioGroup.volume;
    var calculatedVolume = sound.gainAdjustedVolume(this.vol);

    if (sound.fadeInStart !== sound.fadeInEnd && currentTime < sound.fadeInStart) {
      calculatedVolume = 0;
      log('pre-fade-in volume is 0');
    } else if (sound.fadeInStart !== sound.fadeInEnd && currentTime >= sound.fadeInStart && currentTime <= sound.fadeInEnd) {
      // ramp up from 0 - 100%
      calculatedVolume = (currentTime - sound.fadeInStart) / (sound.fadeInEnd - sound.fadeInStart) * calculatedVolume;
      log('ramping  volume', {
        currentTime: currentTime,
        currentVolume: currentVolume,
        calculatedVolume: calculatedVolume,
        sound: sound
      });
    } else if (sound.fadeOutStart !== sound.fadeOutEnd && currentTime > sound.fadeOutEnd) {
      calculatedVolume = 0;
      log('post-fade-out volume is 0');
    } else if (sound.fadeOutStart !== sound.fadeOutEnd && currentTime >= sound.fadeOutStart && currentTime <= sound.fadeOutEnd) {
      // ramp down from 100% to 0
      calculatedVolume = (1 - (currentTime - sound.fadeOutStart) / (sound.fadeOutEnd - sound.fadeOutStart)) * calculatedVolume;
      log('ramping  volume', {
        currentTime: currentTime,
        currentVolume: currentVolume,
        calculatedVolume: calculatedVolume,
        sound: sound
      });
    }

    if (currentVolume !== calculatedVolume) {
      if (Speaker.IOS) {
        if (!brokenWebkit) {
          audioGroup.gain.value = calculatedVolume;
        }
      } else {
        audioGroup.audio.volume = calculatedVolume;
      }

      audioGroup.volume = calculatedVolume;
    }
  },
  _debugAudioObject: function _debugAudioObject(object) {
    var events = ['abort', 'load', 'loadend', 'loadstart', 'loadeddata', 'loadedmetadata', 'canplay', 'canplaythrough', 'seeked', 'seeking', 'stalled', 'timeupdate', 'volumechange', 'waiting', 'durationchange', 'progress', 'emptied', 'ended', 'play', 'pause', 'error'];
    var speaker = this;

    for (var i = 0; i < events.length; i++) {
      object.addEventListener(events[i], function (event) {
        var audio = event.currentTarget;
        var name = audio === speaker.active.audio ? 'active' : audio === speaker.preparing.audio ? 'preparing' : 'fading';
        log(name + ': ' + event.type);
        log('    active: ' + d(speaker.active.audio));
        log('    preparing: ' + d(speaker.preparing.audio));
        log('    fading: ' + d(speaker.fading.audio));

        if (audio.src === SILENCE) {
          return;
        }
      });
    }
  },
  // Create and return new sound object. This throws the song into
  // the preparing audio instance.
  create: function create(url, optionsAndCallbacks) {
    var id = uniqueId('feed-play-');
    var sound = new Sound(this, optionsAndCallbacks, id, url);
    log('created play ' + id + ' (' + url + ')', optionsAndCallbacks);
    this.outstandingSounds[sound.id] = sound; // start loading sound, if we can
    //this.prepare(url, optionsAndCallbacks.startPosition);

    return sound;
  },

  /**
   * This function checks to see if we can prepare the given audio. 
   * If it believes we can, it calls _prepare to put the audio in the
   * prepared audio element and actually prepare it. If it doesn't 
   * believe we can, it makes a note of what we want prepared.
   * 
   * @param {string} url 
   * @param {number} startPosition?
   * @returns true if the song is already loaded up and ready to play
   */
  prepare: function prepare(url) {
    var startPosition = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

    if (!this.active || !this.active.audio) {
      if (hasBlobSupport()) {
        log('pre-loading audio', {
          url: url
        });
        return this._preload(url);
      } else {
        log('saving url to prepare when audio is initialized', {
          url: url,
          startPosition: startPosition
        });
        this.prepareWhenReady = {
          url: url,
          startPosition: startPosition
        };
        return false;
      }
    }

    var ranges = this.active.audio.buffered;
    var range = ranges.length > 0 && ranges.end(ranges.length - 1);

    if (range >= this.active.audio.duration) {
      log('active song has loaded enough, so preparing', url);

      if (hasBlobSupport()) {
        return this._preload(url);
      } else {
        return this._prepare(url, startPosition);
      }
    } else if (this.active.audio.src === SILENCE) {
      log('preparing over silence');

      if (hasBlobSupport()) {
        return this._preload(url);
      } else {
        return this._prepare(url, startPosition);
      }
    } // still loading primary audio - so hold off for now


    log('still loading primary, so waiting to do active prepare', {
      activeUrl: this.active.audio.src,
      range: range
    });
    this.prepareWhenReady = {
      url: url,
      startPosition: startPosition
    };
    return false;
  },

  /* eslint-disable no-console */
  logState: function logState(label) {
    // local testing:
    console.group('speaker: ' + (label || ''));

    if (!this.active) {
      console.group('active');
      console.log('uninitialized');
      console.groupEnd();
      console.group('preparing');
      console.log('uninitialized');
      console.groupEnd();
      console.group('fading');
      console.log('uninitialized');
      console.groupEnd();
    } else {
      console.group('active');
      console.log("audio.src: ".concat(this.active.audio.src));
      console.log("audio.paused: ".concat(this.active.audio.paused));
      console.log("sound: ".concat(this.active.sound ? this.active.sound.id : 'NULL'));
      console.log("volume: ".concat(this.active.volume));
      console.groupEnd();
      console.group('preparing');
      console.log("audio.src: ".concat(this.preparing.audio.src));
      console.log("audio.paused: ".concat(this.preparing.audio.paused));
      console.log("sound: ".concat(this.preparing.sound ? this.preparing.sound.id : 'NULL'));
      console.log("volume: ".concat(this.preparing.volume));
      console.groupEnd();
      console.group('fading');
      console.log("audio.src: ".concat(this.fading.audio.src));
      console.log("audio.paused: ".concat(this.fading.audio.paused));
      console.log("sound: ".concat(this.fading.sound ? this.fading.sound.id : 'NULL'));
      console.log("volume: ".concat(this.fading.volume));
      console.groupEnd();
    }

    console.group('outstanding sounds');

    for (var id in this.outstandingSounds) {
      var play = this.outstandingSounds[id];
      console.log(play.id + ': ' + play.url);
    }

    console.groupEnd();
    console.groupEnd();
  },

  /** 
   * This function tries to fetch the given URL and convert it
   * into a blob url. If the URL is already loaded up, this
   * returns true.
   * 
   * @param {string} url url to load into memory
   * @returns true if the url is already loaded up
   **/
  _preload: function _preload(url) {
    log('preloading!');
    this.prepareWhenReady = null;

    if (this.preloaded) {
      if (this.preloaded.url === url) {
        // true when already loaded up
        var preloaded = !!this.preloaded.blobUrl;
        log('preloading', {
          url: url,
          preloaded: preloaded
        });
        return preloaded;
      }

      if (this.preloaded.blobUrl) {
        log('revoking previously loaded url', {
          url: this.preloaded.url
        }); // unload previous blob

        URL.revokeObjectURL(this.preloaded.blobUrl);
        this.preloaded = null;
      }
    }

    this.preloaded = {
      url: url,
      blobUrl: null,
      responses: []
    };

    this._fetch(url, this.preloaded.responses);

    return false;
  },
  _fetch: function _fetch(url, responses) {
    var _this = this;

    var attempt = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    log("preload attempt #".concat(attempt), {
      url: url
    });
    var response = {
      start: new Date().toString()
    };
    responses.push(response);

    var retry = function retry() {
      if (!_this.preloaded || _this.preloaded.url !== url) {
        log('preload abandoning retry because we have moved on', {
          url: url
        });
        return;
      }

      if (attempt > _this.maxRetries) {
        log('preload failed to fetch', {
          url: url,
          responses: responses
        });
        _this.preloaded = null;

        _this.trigger('prepared', url, false, responses);

        return;
      }

      setTimeout(function () {
        return _this._fetch(url, responses, attempt + 1);
      }, Math.min(Math.pow(10, attempt), 10000));
    };

    log('preloading', {
      url: url,
      responses: responses
    }); // stress test:
    // const extra = (Math.random() < 0.7) ? '-extrajunkj' : '';

    fetch(url
    /* + extra */
    ).then(function (res) {
      log('preload got response');
      response.end = new Date().toString();
      response.status = res.status;
      response.text = res.statusText;
      response.headers = _toConsumableArray(res.headers.entries()); // if res.type == 'opaque', could cause problems

      if (res.type === 'opaque') {
        log('preload opaque response, so retrying');
        response.name = 'OpaqueResponse';
        response.message = 'Browser returned oaque response';
        retry();
        return;
      }

      if (!res.ok) {
        log('preload fetch error - retrying');
        retry();
        return;
      }

      res.blob().then(function (blob) {
        log('preload got blob');

        if (_this.preloaded && _this.preloaded.url === url) {
          log('preloaded', {
            url: url
          });
          var properMimeTypeBlob = new Blob([blob], {
            type: 'audio/mpeg'
          });
          _this.preloaded.blobUrl = URL.createObjectURL(properMimeTypeBlob);

          _this.trigger('prepared', url, true, responses);
        } else {
          // finished retrieving file, but nobody cares any more
          log('preload retrieved url, but nobody cares any more');
        }
      }).catch(function (err) {
        log('preload error blobbing', err, err.name, err.message);
        response.name = err.name;
        response.message = err.message;
        retry();
      });
    }).catch(function (err) {
      log('preload error', err, err.name, err.message); // connectivity error 

      response.end = new Date().toString();
      response.name = err.name;
      response.message = err.message;
      retry();
    });
  },

  /**
  * This function puts the given URL into the prepared audio element and tells
  * the browser to advance to the given start position.
  * 
  * @param {*} url 
  * @param {*} startPosition 
  * @returns true if the song is already loaded up and ready to play
  */
  _prepare: function _prepare(url, startPosition) {
    // empty out any pending request
    this.prepareWhenReady = null;

    if (!url) {
      return false;
    }

    if (this.preparing && this.preparing.audio.src === url && this.preparing.canplaythrough) {
      log('play already prepared!'); // song is already prepared!

      return true;
    }

    if (this.preparing.audio.src !== url) {
      log('preparing', url);

      if (this.preparing.audio.playing) {
        this.preparing.audio.pause();
      }

      this.preparing.canplaythrough = false;
      revoke(this.preparing.audio);
      this.preparing.audio.src = url;
    }

    if (startPosition && this.preparing.audio.currentTime !== startPosition) {
      log('advancing preparing audio to', startPosition / 1000);
      this.preparing.audio.currentTime = startPosition / 1000;
    }

    return false;
  },

  /*
   * Kick off playback of the requested sound.
   */
  _playSound: function _playSound(sound) {
    var _this2 = this;

    var speaker = this;

    if (!this.active || !this.active.audio) {
      // eslint-disable-next-line
      console.error('**** player.initializeAudio() *** not called before playback!');
      return;
    }

    if (this.active.sound === sound) {
      if (this.active.audio.paused) {
        log(sound.id + ' was paused, so resuming'); // resume playback

        this.active.audio.play().then(function () {
          log('resumed playback');
          sound.trigger('play');
        }).catch(function (e) {
          log('error resuming playback', e.name, e.message, e.stack, sound.id);
          speaker.active.sound = null;
          sound.trigger('finish');
        });

        if (this.fading.sound) {
          this.fading.audio.play().then(function () {
            log('resumed fading playback');
          }).catch(function (e) {
            log('error resuming fading playback', e.name, e.message, e.stack, sound.id);
            speaker.fading.sound = null;
            revoke(speaker.fading.audio);
            speaker.fading.audio.src = SILENCE;
          });
        }
      } else {
        log(sound.id + ' is already playing');
      }

      return;
    }

    if (this.preloaded && this.preloaded.url === sound.url && this.preloaded.blobUrl) {
      log(sound.id + ' using preloaded audio', this.preloaded);

      if (this.preparing.audio.playing) {
        this.preparing.audio.pause();
      }

      sound.responses = this.preloaded.responses;
      revoke(this.preparing.audio);
      this.preparing.audio.src = this.preloaded.blobUrl;
      this.preparing.canplaythrough = true;
      this.preloaded = null;
    } else if (this.preparing.audio.src !== sound.url) {
      // hopefully, by this time, any sound that was destroyed before its
      // play() call completed has actually completed its play call. Otherwise
      // this will trigger an exception in the play preparation.
      this._prepare(sound.url, sound.startPosition);
    } // swap prepared -> active


    var active = this.active;
    this.active = this.preparing;
    this.preparing = active;
    this.preparing.canplaythrough = false;
    revoke(this.preparing.audio);
    this.preparing.audio.src = SILENCE; // don't throw sound object in active until playback starts (below)

    this.active.sound = null;

    this._setVolume(this.active, sound); // notify clients that whatever was previously playing has finished


    if (this.preparing.sound) {
      var finishedSound = this.preparing.sound;
      this.preparing.sound = null;
      finishedSound.trigger('finish');
    }

    sound.awaitingPlayResponse = true;
    this.active.sound = sound;
    var me = this.active;
    var attempt = 1;

    var play = function play() {
      log(sound.id + ' initiating play()', {
        attempt: attempt
      });

      _this2.active.audio.play().then(function () {
        delete sound.awaitingPlayResponse;

        if (!speaker.outstandingSounds[sound.id]) {
          log(sound.id + ' play() succeeded, but sound has been destroyed'); // this sound was killed before playback began - make sure to stop it

          if (me.audio && me.audio.src === sound.url) {
            log(sound.id + ' being paused and unloaded');
            me.audio.pause();
            revoke(me.audio);
            me.audio.src = SILENCE;
          }

          return;
        }

        log(sound.id + ' play() succeeded'); // configure fade-out now that metadata is loaded

        if (sound.fadeOutSeconds && sound.fadeOutEnd === 0) {
          sound.fadeOutStart = me.audio.duration - sound.fadeOutSeconds;
          sound.fadeOutEnd = me.audio.duration;
        }

        if (sound.startPosition) {
          log('updating start position');
          me.audio.currentTime = sound.startPosition / 1000;
          log('updated');
        }

        var paused = me.audio.paused;
        sound.trigger('play');

        if (me.pauseAfterPlay) {
          me.audio.pause();
        } else if (paused) {
          sound.trigger('pause');
        }
      }).catch(function (error) {
        log('error starting playback with sound ' + sound.id, {
          name: error.name,
          message: error.message,
          attempt: attempt
        });

        if (attempt < 4) {
          attempt++;
          setTimeout(play, 10);
        } else {
          sound.trigger('finish', error);
        }
      });
    };

    play();
  },
  _destroySound: function _destroySound(sound) {
    var fadeOut = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    sound.off();

    if (this.active && this.active.sound === sound) {
      if (!fadeOut || !sound.fadeOutSeconds) {
        log('destroy triggered for current sound (no fadeout)', sound.id);
        this.active.audio.pause();
        revoke(this.active.audio);
        this.active.audio.src = SILENCE;
      } else {
        log('destroy triggered for current sound (with fadeout)', sound.id);
        var audio = this.active.audio;
        sound.fadeOutStart = audio.currentTime;

        if (sound.endPosition) {
          sound.fadeOutEnd = Math.min(audio.currentTime + sound.fadeOutSeconds, sound.endPosition / 1000);
          sound.endPosition = Math.min(sound.fadeOutEnd * 1000, sound.endPosition);
        } else {
          sound.fadeOutEnd = audio.currentTime + sound.fadeOutSeconds;
          sound.endPosition = sound.fadeOutEnd * 1000;
        } // song hit start of fade out


        this._setVolume(this.active); // active becomes fading, and fading becomes active


        var fading = this.fading;
        this.fading = this.active;
        this.active = fading;
        this.active.sound = null; // not used any more 
      }
    } else {
      log('destroy triggered for inactive sound', sound.id); // if (this.active && (this.active.audio.sound === sound)) {
      //   We're destroying the active sound, but it hasn't completed its play()
      //   yet (indicated by this.active.sound === sound), so we can't pause it
      //   here. When the play does complete, it will notice it isn't in the 
      //   outstandingSounds map and it will pause itself
      // }
    }

    delete this.outstandingSounds[sound.id];
  },
  flush: function flush() {
    // destroy all outstanding sound objects
    for (var id in this.outstandingSounds) {
      this.outstandingSounds[id].destroy();
    }
  },
  _pauseSound: function _pauseSound(sound) {
    if (this.active && sound === this.active.sound) {
      if (sound.awaitingPlayResponse) {
        // wait for the play() call to complete before pausing, otherwise
        // we'll get an exception
        this.active.pauseAfterPlay = true;
      } else {
        this.active.audio.pause();
      }
    }

    if (this.fading && this.fading.audio) {
      this.fading.audio.pause();
    }
  },
  _position: function _position(sound) {
    if (this.active && sound === this.active.sound) {
      return Math.floor(this.active.audio.currentTime * 1000);
    } else {
      return 0;
    }
  },
  _duration: function _duration(sound) {
    if (sound === this.active.sound) {
      var durationRounded = isNaN(this.active.audio.duration) ? 0 : Math.round(this.active.audio.duration);
      return durationRounded * 1000;
    } else {
      return 0;
    }
  },
  // set the volume (0-100)
  setVolume: function setVolume(value) {
    if (typeof value !== 'undefined') {
      this.vol = value;

      if (this.active && this.active.sound) {
        this._setVolume(this.active);
      }

      this.trigger('volume', value);
    }

    return this.vol;
  },
  getVolume: function getVolume() {
    return this.vol;
  }
};

function revoke(audio) {
  if (audio.src.slice(0, 4) === 'blob') {
    log('revoking', {
      url: audio.src
    });
    URL.revokeObjectURL(audio.src);
  }
} // add events to speaker class


Object.assign(Speaker.prototype, Events);

/*
 *  Feed Media Player
 *
 *  This class requests and plays audio files from the feed servers. It
 *  makes use of the Session class to communicate with the server. There
 *  should technically only ever be one instance of this class in a page.
 *  This class does no UI - that should be handled by Feed.PlayerView 
 *  or similar.
 *
 *  Create this with:
 *    player = new Feed.Player(token, secret[, options])
 *
 *  options can be:
 *    debug: false,         // when true, display console logging statements
 *    remoteLogging: false  // when true, failed play starts or errors will cause the
 *                          // last 500 log entries from the player to be sent to
 *                          // feed.fm to assist with debugging.
 *    trimming: true,       // when true, song start/end trims will be honored
 *    crossfadeIn: false,   // when true, songs do not fade in - they start at full volume
 *    normalizeVolume: true, // automatically adjust volume of songs in station to be at same approx loudness
 *    secondsOfCrossfade: 0 // number of seconds to crossfade songs during song transitions (note: this might be
 *                          // overidden by the server)
 *    simulcast: 'uuid'     // id to announce music playback on, for simulcast listeners
 *    maxRetries: 6         // max number of times to retry retrieving a song before giving up
 *    resumable: true       // when true, playback can be resumed after a page refresh with Feed.resumable();
 *
 *  In response to a user-interaction event, and before you begin any
 *  music playback, be sure to call:
 *
 *    player.initializeAudio();
 *
 *  That will ensure the library has permission from the browser to play
 *  audio.
 * 
 *  To retrieve a list of available stations, register for the 'stations' event,
 *  and then call `player.tune()`:
 * 
 *    player.on('stations', function(stations) {
 *       console.log('available stations', stations);
 *    });
 *    player.tune();
 * 
 *  or use the promise returned from `player.tune()`:
 *
 *    let stations = await player.tune();
 *
 *  Then control playback with:
 *
 *    play() - start playing the current placement/station or resume the current song
 *    pause() - pause playback of the current song, if any
 *    like() - tell the server we like this song
 *    unlike() - tell the server to remove the 'like' for this song
 *    dislike() - tell the server we dislike this song, and skip to the next one
 *    skip() - request to skip the current song
 *    setStationId(id [, fade]) - switch to a different station. Optionally set 'fade' to true to
 *         crossfade playback to the new station. This has a side effect of triggering
 *         a 'station-changed' event.
 *    setStationId(id, advanceTo) - switch to station with id `id`, and begin playback of that
 *         station at `advanceTo` seconds from the start of the station. This only works for first play
 *         or single play stations, and will trigger an error for other stations.
 *    setVolume(xxx) - adjust music volume (0-100)
 *    getVolume() - retrieve music volume (0-100)
 *
 *  player has a current state that can be queried with 'getCurrentState()':
 *    uninitialized - player is still trying to initialize
 *    unavailable - no music is available
 *    idle - ready for playback, not playing anything
 *    playing - if session.hasActivePlayStarted() and we're not paused
 *    paused -  if session.hasActivePlayStarted() and we're paused
 * 
 *  events emitted by the player:
 *    station-changed - the current station from which music is pulled has changed.
 *                      this is triggered in response to a 
 *    stations - this is triggered after a call to `tune()`, and passes the event handler an
 *               array of all stations available for playback. Alterntively, the
 *               `getStations()` method returns a promise that resolves to the same
 *               value.
 *    music-unavailable - user isn't located in the US and can't play music
 *    play-started - this play has begun playback. The event handler is passed a 
 *                   'play' object with song metadata. If the event was triggered
 *                   via a `Feed.resumable().tune()` call, then a second argument
 *                   of `true` will be passed to the event handler.
 *    play-paused - the currently playing song has been paused. The event handler
 *                    is passed a 'play' object with song metadata. if the event
 *                   was triggered via a `Feed.resumable().tune()` call, then a
 *                   second argument of `true` will be passed to the event handler.
 *    play-stopped - player.stop() has been called
 *    skip-denied - the given song could not be skipped due to DMCA rules
 *    skip-failed - the request to skip a song was denied
 *    forbidden - an unsatisfiable request for music was made (currently only
 *       triggered when trying to start playback in the middle of a non-first
 *       play station with the `advanceTo` argument to `setStationId`)
 *
 *  Some misc methods:
 *
 *    setMuted(muted)
 *    canLike() - returns true if the current song may be liked/unliked/disliked
 *    canSkip() - returns true if the current song may be skipped (some stations have
 *        skip frequency limits or disable skipping entirely)
 *
 */

function supports_html5_storage$1() {
  try {
    return 'localStorage' in window && window['localStorage'] !== null && (window.localStorage['feed-test'] = true);
  } catch (e) {
    return false;
  }
}

var Player = function Player(token, secret, options) {
  var _this = this;

  if (!secret) {
    // restore from saved state
    this._restore(token);
  } else {
    options = options || {};
    options.maxRetries = options.maxRetries || 10;
    this.options = options;
    this.state = {
      paused: true,
      // activePlay
      simulcast: options.simulcast
    };

    if (options.debug) {
      log.enable();
    } // this._station = current station
    // this._stations = list of available stations
    // this._placement = current placement


    this.trimming = options.trimming === false ? false : true;
    this.normalizeVolume = 'normalizeVolume' in options ? options.normalizeVolume : true;
    this.resumable = 'resumable' in options ? options.resumable : true;
    this.secondsOfCrossfade = options.secondsOfCrossfade || 0;
    this.crossfadeIn = !!options.crossfadeIn;
    this.serverAssignedCrossfade = false;
    this._stationsPromise = new Promise(function (resolve, reject) {
      _this._stationsResolve = resolve;
      _this._stationsReject = reject;
    });
    var speaker = this.speaker = new Speaker({
      maxRetries: options.maxRetries
    });
    var session = this.session = new Session(token, secret, options);

    if (options.brokenWebkitFormats && Speaker.brokenWebkit) {
      var reqFormatList = options.brokenWebkitFormats.split(','),
          suppFormatList = speaker.getSupportedFormats().split(','),
          reqAndSuppFormatList = intersection(reqFormatList, suppFormatList),
          reqAndSuppFormats = reqAndSuppFormatList.join(',');
      log('input format list is', reqFormatList, suppFormatList);
      log('final support list is', reqAndSuppFormats);

      if (reqAndSuppFormatList.length === 0) {
        reqAndSuppFormats = speaker.getSupportedFormats();
      }

      session.setFormats(reqAndSuppFormats);
    } else if (options.formats) {
      var _reqFormatList = options.formats.split(','),
          _suppFormatList = speaker.getSupportedFormats().split(','),
          _reqAndSuppFormatList = intersection(_reqFormatList, _suppFormatList),
          _reqAndSuppFormats = _reqAndSuppFormatList.join(',');

      if (_reqAndSuppFormatList.length === 0) {
        _reqAndSuppFormats = speaker.getSupportedFormats();
      }

      log('input format list is', _reqFormatList, _suppFormatList);
      log('final support list is', _reqAndSuppFormats);
      session.setFormats(_reqAndSuppFormats);
    } else {
      session.setFormats(speaker.getSupportedFormats());
    }
  }

  Object.assign(this, Events);
  this.session.on('play-active', this._onPlayActive, this);
  this.session.on('play-started', this._onPlayStarted, this);
  this.session.on('play-completed', this._onPlayCompleted, this);
  this.session.on('plays-exhausted', this._onPlaysExhausted, this);
  this.session.on('prepare-sound', this._onPrepareSound, this);
  this.session.on('placement', this._onPlacement, this);
  this.session.on('stations', this._onStations, this);
  this.session.on('station-changed', this._onStationChanged, this);
  var player = this;

  var _loop = function _loop() {
    var event = _arr[_i];

    _this.session.on(event, function () {
      player.trigger.apply(player, [event].concat(Array.prototype.slice.call(arguments, 0)));
    });
  };

  for (var _i = 0, _arr = ['music-unavailable', 'not-in-us', 'invalid-credentials', 'skip-denied', 'play-active', 'forbidden']; _i < _arr.length; _i++) {
    _loop();
  }

  this.setMuted(this.isMuted());
};

Player.prototype._persist = function () {
  var playerState = shallowCopy(this.state);

  if (playerState.activePlay) {
    // remove the 'sound' object
    playerState.activePlay = shallowCopy(playerState.activePlay);
    delete playerState.activePlay.sound;
  }

  var persisted = {
    state: playerState,
    options: this.options,
    trimming: this.trimming,
    normalizeVolume: this.normalizeVolume,
    secondsOfCrossfade: this.secondsOfCrossfade,
    serverAssignedCrossfade: this.serverAssignedCrossfade,
    crossfadeIn: this.crossfadeIn,
    sessionConfig: this.session.config
  };
  return persisted;
};

Player.prototype._restore = function (_ref) {
  var _this2 = this;

  var persisted = _ref.persisted,
      elapsed = _ref.elapsed;

  if (persisted.options.debug) {
    log.enable();
  }

  log('restoring!'); // session will be initialized with no current play

  var sessionConfig = persisted.sessionConfig;
  var sessionCurrent = sessionConfig.current;
  sessionConfig.current = null;
  sessionConfig.pendingRequest = null;
  sessionConfig.pendingPlay = null;
  this.session = new Session();
  this.session.config = sessionConfig;
  this.options = persisted.options;
  this.speaker = new Speaker({
    maxRetries: this.options.maxRetries
  }); // start off in paused state

  this.state = {
    paused: true,
    simulcast: this.options.simulcast
  };
  this.trimming = persisted.trimming;
  this.normalizeVolume = persisted.normalizeVolume;
  this.resumable = true;
  this.secondsOfCrossfade = persisted.secondsOfCrossfade;
  this.serverAssignedCrossfade = persisted.serverAssignedCrossfade;
  this.crossfadeIn = persisted.crossfadeIn;
  this._stationsPromise = new Promise(function (resolve, reject) {
    _this2._stationsResolve = resolve;
    _this2._stationsReject = reject;
  }); // at this point, we're in a state similar to a newly initialized player,
  // but the session object has placement/station info
  // swap out the default tune

  this.tune = function () {
    var _this3 = this;

    // on the next tick, throw out events to simulate a normal tune() call
    return Promise.resolve(true).then(function () {
      _this3._station = persisted.sessionConfig.station;
      _this3._stations = persisted.sessionConfig.stations;
      _this3._placement = persisted.sessionConfig.placement;

      _this3._stationsResolve(persisted._stations);

      _this3.trigger('placement', _this3._placement);

      _this3.trigger('station-changed', _this3._station);

      _this3.trigger('stations', _this3._stations); // stick the previously active song into the session


      _this3.session.config.current = sessionCurrent;
      _this3.session.config.current.started = false;
      var play = _this3.session.config.current.play; // get the player to create a sound object with the audio advanced to the
      // old elapsed position

      play.start_at = elapsed / 1000;

      _this3.session.trigger('play-active', play);

      _this3.session.config.current.started = true; // pretend the song was started

      _this3.state.paused = false;

      _this3.session.trigger('play-started', play, true); // announce that the song is paused


      _this3.state.paused = true;

      _this3.trigger('play-paused', play, true); // now we're in the same spot we'd be if we played and paused.

    }).then(function () {
      return _this3._stationsPromise;
    });
  };
};

Player.prototype.initializeAudio = function () {
  log('INTIALIZE AUDIO');
  this.speaker.initializeAudio();
};

Player.prototype._onPlacement = function (placement) {
  this._placement = placement;

  if (placement.options && placement.options.crossfade_seconds) {
    this.secondsOfCrossfade = placement.options.crossfade_seconds;
    this.serverAssignedCrossfade = true;
  }

  this.trigger('placement', placement);
};

Player.prototype._onStations = function (stations) {
  this._stations = stations;

  this._stationsResolve(stations);

  this.trigger('stations', stations);
};

Player.prototype._onStationChanged = function (stationId, station) {
  this._station = station;

  if (this.serverAssignedCrossfade && station.options && 'crossfade_seconds' in station.options) {
    // apply station level crossfade, if available
    this.secondsOfCrossfade = station.options.crossfade_seconds;
  } else if (this.serverAssignedCrossfade && this._placement.options && 'crossfade_seconds' in this._placement.options) {
    // revert to placement level crossfade, if available
    this.secondsOfCrossfade = this._placement.options.crossfade_seconds;
  }

  this.trigger('station-changed', stationId, station);
};

Player.prototype.setStationId = function (stationId, fadeOutOrAdvance) {
  var advance;
  var fadeOut = false;

  if (fadeOutOrAdvance === true) {
    fadeOut = fadeOutOrAdvance;
    log('SET STATION ID (WITH FADE)', stationId);
  } else if (fadeOutOrAdvance) {
    advance = fadeOutOrAdvance;
    log('SET STATION ID (WITH ADVANCE)', stationId, advance);
  } else {
    log('SET STATION ID', stationId);
  }

  if (fadeOut && this.state.activePlay) {
    // when we destroy the sound, have it fade out
    this.state.activePlay.fadeOnDestroy = true;
  }

  this.session.setStationId(stationId, advance, this.crossfadeIn);
};

Player.prototype._onPlayActive = function (play) {
  // create a new sound object
  var options = {
    play: this._onSoundPlay.bind(this, play.id),
    pause: this._onSoundPause.bind(this, play.id),
    finish: this._onSoundFinish.bind(this, play.id),
    elapse: this._onSoundElapse.bind(this, play.id)
  };

  if (this.normalizeVolume) {
    options.gain = (play.audio_file.replaygain_track_gain || 0) + (play.station.pre_gain || 0);
  }

  if (play.start_at) {
    // when offsetting into a station, ignore the trim and honor the start_at
    options.startPosition = play.start_at * 1000;
  } else {
    if (this.trimming && play.audio_file.extra && play.audio_file.extra.trim_start) {
      options.startPosition = play.audio_file.extra.trim_start * 1000;
    }
  }

  if (this.trimming && play.audio_file.extra && play.audio_file.extra.trim_end && play.audio_file.duration_in_seconds) {
    options.endPosition = (play.audio_file.duration_in_seconds - play.audio_file.extra.trim_end) * 1000;
  }

  if (this.secondsOfCrossfade) {
    if (this.crossfadeIn) {
      options.fadeInSeconds = this.secondsOfCrossfade;
    }

    options.fadeOutSeconds = this.secondsOfCrossfade;
  }

  var sound = this.speaker.create(play.audio_file.url, options);
  this.state.activePlay = {
    id: play.id,
    sound: sound,
    startReportedToServer: false,
    // whether we got a 'play-started' event from session
    soundCompleted: false,
    // whether the sound object told us it finished playback
    playStarted: false,
    // whether playback started on the sound object yet
    fadeOnDestroy: false,
    // when true, apply a fade out when destroying the sound
    previousPosition: 0 // last time we got an 'elapse' callback

  }; // if we're not paused, then start it

  if (!this.state.paused) {
    var s = this.state.activePlay.sound;
    s.play();
  }
};

Player.prototype._onSoundPlay = function (playId) {
  // sound started playing
  if (!this.state.activePlay || this.state.activePlay.id !== playId) {
    log('received sound play, but active play does not match', this.state.activePlay, playId);
    return;
  }

  this.state.paused = false;
  var playerWasResumed = this.state.activePlay.playStarted;
  this.state.activePlay.playStarted = true; // on the first play, tell the server we're good to go

  if (!this.state.activePlay.startReportedToServer) {
    // save the state so we can restore
    if (this.resumable) {
      persistState(this._persist());
    }

    return this.session.reportPlayStarted();
  } else if (playerWasResumed) {
    // subsequent plays are considered 'resumed' events
    this.trigger('play-resumed', this.session.getActivePlay());
  }
};

Player.prototype.getActivePlay = function () {
  return this.session.getActivePlay();
};

Player.prototype.hasActivePlayStarted = function () {
  return this.session.hasActivePlayStarted();
};

Player.prototype.getActivePlacement = function () {
  return this.session.getActivePlacement();
};

Player.prototype._onSoundPause = function (playId) {
  // sound paused playback
  if (!this.state.activePlay || this.state.activePlay.id !== playId) {
    log('received sound pause, but active play does not match', this.state.activePlay, playId);
    return;
  }

  this.state.paused = true;
  this.trigger('play-paused', this.session.getActivePlay());
};

Player.prototype._onSoundFinish = function (playId, withError) {
  if (!this.state.activePlay || this.state.activePlay.id !== playId) {
    log('received sound finish, but active play does not match', this.state.activePlay, playId);
    return;
  }

  var sound = this.state.activePlay.sound;
  this.state.activePlay.soundCompleted = true;

  if (withError) {
    this.session._submitEvent('playback-error', {
      url: sound.url,
      responses: sound.responses,
      error: withError,
      play_id: playId
    });

    this.state.activePlay.soundCompletedWithError = true;

    if (withError.name === 'NotAllowedError') {
      // eslint-disable-next-line no-console
      console.error('Feed.fm: first call to "initializeAudio()" or "play()" must be made in user-initiated event handler');
      this.stop();
      return;
    }
  }

  if (!this.state.activePlay.playStarted) {
    // never reported this as started...  mark it as invalidated so
    // we can advance.
    this.trigger('invalidated', playId);
    this.session.requestInvalidate();
    return;
  }

  if (!this.state.activePlay.startReportedToServer) {
    // if the song failed before we recieved start response, wait
    // until word from the server that we started before we say
    // that we completed the song
    return;
  }

  if (withError) {
    log('song completed with error - marking as invalid', withError);
    this.trigger('invalidated', playId);
    this.session.requestInvalidate();
  } else {
    this.session.reportPlayCompleted();
  }
};

Player.prototype._onSoundElapse = function (playId) {
  if (!this.state.activePlay || this.state.activePlay.id !== playId) {
    log('received sound elapse, but active play does not match', this.state.activePlay, playId);
    return;
  }

  var sound = this.state.activePlay.sound,
      position = sound.position(),
      interval = 30 * 1000,
      // ping server every 30 seconds
  previousCount = Math.floor(this.state.activePlay.previousPosition / interval),
      currentCount = Math.floor(position / interval);

  if (this.resumable) {
    persistElapsed(position);
  }

  this.state.activePlay.previousPosition = position;

  if (currentCount !== previousCount) {
    this.session.reportPlayElapsed(Math.floor(position / 1000));
  }
};

Player.prototype._onPlayStarted = function (play) {
  var _this4 = this;

  var session = this.session;

  if (!this.state.activePlay || this.state.activePlay.id !== play.id) {
    log('received play started, but it does not match active play', play, this.state.activePlay);
    return;
  }

  this.state.activePlay.startReportedToServer = true;

  if (this.state.activePlay.soundCompleted) {
    // the audio completed playback before the session announced the play started
    log('sound completed before we finished reporting start', this.state.activePlay); // In the normal case we'd just quit here, but since the audio completed playback
    // already, we've got to make sure a 'session.reportPlayCompleted()' gets kicked
    // off to record the completion of this song.
    // Defer the reporting so other 'play-started' handlers can complete as normal
    // before a 'play-completed' gets triggered

    if (this.state.activePlay.soundCompletedWithError) {
      setTimeout(function () {
        _this4.trigger('invalidated', play.id);

        session.requestInvalidate();
      }, 1);
    } else {
      setTimeout(function () {
        return session.reportPlayCompleted();
      }, 1);
    }
  }

  this.updateSimulcast();
  this.trigger('play-started', play);
};

Player.prototype._onPlayCompleted = function (play) {
  if (!this.state.activePlay || this.state.activePlay.id !== play.id) {
    log('received play completed, but it does not match active play', play, this.state.activePlay);
    return;
  }

  this.state.activePlay.sound.destroy(this.state.activePlay.fadeOnDestroy);
  var started = this.state.activePlay.playStarted;
  delete this.state.activePlay;

  if (started) {
    this.trigger('play-completed', play);
  } // skip to complete the current song.
  //this.state.paused = false;

};

Player.prototype._onPlaysExhausted = function () {
  if (this.state.paused) {
    return;
  }

  this.state.paused = false;
  this.updateSimulcast();
  this.trigger('plays-exhausted');
};

Player.prototype._onPrepareSound = function (url, startPosition, playId) {
  var _this5 = this;

  log('preparing sound', url, startPosition);
  this.speaker.prepare(url, startPosition * 1000);
  this.speaker.once('prepared', function (preparedUrl, success, headers) {
    if (url !== preparedUrl) {
      return;
    }

    if (headers && headers.length > 1) {
      _this5.session._submitEvent('preload-error', {
        url: url,
        play_id: playId,
        responses: headers
      });
    }

    var activePlay = _this5.session.getActivePlay();

    if (!success && (!activePlay || activePlay.id !== playId)) {
      _this5.session.requestInvalidate(url);
    }
  });
};

Player.prototype.isPaused = function () {
  return this.session.isTuned() && this.state.paused;
};

Player.prototype.tune = function () {
  log('TUNE');

  if (!this.session.isTuned()) {
    this.session.tune();
  }

  return this._stationsPromise;
};
/**
 * This call triggers the SDK to load the next song into memory and
 * returns a promise that resolves when the next song is fully loaded
 * and ready for immediate playback via play().
 * 
 * Additionally, this method triggers a 'prepared' event on the player
 * object when the next song is fully loaded and ready for immediate
 * playback.
 * 
 * Note: a song cannot be fully loaded into memory until initializeAudio()
 * has been called. The promise returned by this method will not resolve
 * unless initializeAudio() is successfully called before or after this
 * method.
 * 
 * @returns Promise that resolves when a song is in memory and ready for immediate playback
 */


Player.prototype.prepare = function () {
  log('PREPARE');
  this.speaker.initializeAudio();
  return this._prepare();
};

Player.prototype._prepare = function () {
  var _this6 = this;

  var ap = this.state.activePlay;

  if (ap) {
    var url = ap.sound.url;
    var prepared = this.speaker.prepare(url, ap.sound.startPosition);

    if (prepared) {
      return Promise.resolve(true).then(function () {
        log('already prepared');

        _this6.trigger('prepared');
      });
    } else {
      return new Promise(function (resolve) {
        log('waiting for un/prepared event');

        _this6.speaker.once('prepared', function (preparedUrl, success, headers) {
          if (headers && headers.length > 1) {
            _this6.session._submitEvent('preload-error', {
              url: preparedUrl,
              play_id: ap.id,
              responses: headers
            });
          }

          if (preparedUrl !== url) {
            return;
          }

          if (success) {
            _this6.trigger('prepared');

            resolve(true);
          } else {
            // invalidate the play, and request a new one
            _this6.session.requestInvalidate();

            _this6.session.once('play-active', function () {
              _this6._prepare().then(function (val) {
                return resolve(val);
              });
            });
          }
        });
      });
    }
  } else {
    return new Promise(function (resolve) {
      _this6.session.once('play-active', function ()
      /* play */
      {
        _this6._prepare().then(function (val) {
          return resolve(val);
        });
      });

      if (!_this6.session.isTuned()) {
        log('tuning');

        _this6.session.tune();
      }
    });
  }
};

Player.prototype.play = function () {
  log('PLAY');
  var session = this.session;
  var state = this.state;
  this.speaker.initializeAudio();

  if (!session.isTuned()) {
    // not currently playing music
    state.paused = false;
    return session.tune();
  }

  if (session.getActivePlay() && state.activePlay && state.paused) {
    // resume playback of song
    if (state.activePlay.playStarted) {
      state.activePlay.sound.resume();
    } else {
      state.activePlay.sound.play();
    }
  } // 'start' event from sound will definitely be asynchronous, so prevent repeated calls


  state.paused = false;
  this.updateSimulcast();
};

Player.prototype.pause = function () {
  log('PAUSE');

  if (!this.session.hasActivePlayStarted() || !this.state.activePlay || this.state.paused) {
    return;
  } // pause current song


  this.state.activePlay.sound.pause(); // 'pause' event from sound might be asynchronous, so prevent repeated calls

  this.state.paused = true;
  this.updateSimulcast();
};
/**
 * Some regions disallow 'like'ing of songs (e.g. Canada). Check this after
 * changing the active station or when a new song starts to know if the current
 * song may be liked/disliked/unliked.
 * 
 * @returns {boolean} true if we can 'like' songs in the currently active station
 */


Player.prototype.canLike = function () {
  return this.session.canLike();
};

Player.prototype.like = function () {
  log('LIKE');

  if (!this.session.hasActivePlayStarted()) {
    return;
  }

  if (!this.session.canLike()) {
    return;
  }

  this.session.likePlay(this.state.activePlay.id);
  this.trigger('play-liked');
};

Player.prototype.unlike = function () {
  log('UNLIKE');

  if (!this.session.hasActivePlayStarted()) {
    return;
  }

  if (!this.session.canLike()) {
    return;
  }

  this.session.unlikePlay(this.state.activePlay.id);
  this.trigger('play-unliked');
};

Player.prototype.dislike = function () {
  log('DISLIKE');

  if (!this.session.hasActivePlayStarted()) {
    return;
  }

  if (!this.session.canLike()) {
    return;
  }

  this.session.dislikePlay(this.state.activePlay.id);
  this.trigger('play-disliked'); // start playback if we're paused and try to advance to next song

  this.state.paused = false;
  this.skip();
};

Player.prototype.skip = function () {
  log('SKIP');

  if (!this.session.hasActivePlayStarted()) {
    // can't skip non-playing song
    return;
  } // cannot skip in station with skipping disabled


  if (!this.session.canSkipInStation()) {
    return;
  }

  this.state.paused = false;
  this.session.requestSkip();
};

Player.prototype.stop = function () {
  log('STOP');
  clearPersistance();
  this.state.paused = true;
  var activePlay = this.state.activePlay;

  if (activePlay && activePlay.sound) {
    log('stopping active play', activePlay);

    if (activePlay.startReportedToServer) {
      // report where we played to
      var position = activePlay.sound.position();
      this.session.reportPlayStopped(Math.floor(position / 1000));
    } // stop any playback


    activePlay.sound.pause();
    activePlay.sound.destroy();
  } else {
    log('no active play');
  }

  delete this.state.activePlay; // flush out any prepared sounds

  this.speaker.flush();
  this.trigger('play-stopped');
  this.updateSimulcast();
};

Player.prototype.destroy = function () {
  this.session = null;

  if (this.state.activePlay && this.state.activePlay.sound) {
    this.state.activePlay.sound.destroy();
  }
};

Player.prototype.getCurrentState = function () {
  if (!this.session.hasActivePlayStarted()) {
    // nothing started, so we're idle
    return 'idle';
  } else {
    if (this.state.paused) {
      return 'paused';
    } else {
      return 'playing';
    }
  }
};

Player.prototype.getPosition = function () {
  if (this.state.activePlay && this.state.activePlay.sound) {
    return this.state.activePlay.sound.position();
  } else {
    return 0;
  }
};

Player.prototype.getDuration = function () {
  if (this.state.activePlay && this.state.activePlay.sound) {
    return this.state.activePlay.sound.duration();
  } else {
    return 0;
  }
};
/**
 * Return true if the user may skip the current song.
 * 
 * @returns {boolean}
 */


Player.prototype.canSkip = function () {
  return this.session.canSkip();
};
/**
 * Technically, you might not be able to skip a song at the time it starts, but
 * eventually enough time might pass that you can skip the song. Hence, we
 * had 'maybeCanSkip'. However, nobody is repeatedly checking for skippability
 * while playing a song, so this method is deprecated.
 */


Player.prototype.maybeCanSkip = function () {
  return this.canSkip();
};

var mutedKey = 'muted';

Player.prototype.isMuted = function () {
  if (supports_html5_storage$1()) {
    if (mutedKey in localStorage) {
      return localStorage[mutedKey] === 'true';
    }
  }

  return false;
};

Player.prototype.setMuted = function (isMuted) {
  if (isMuted) {
    this.speaker.setVolume(0);

    if (supports_html5_storage$1()) {
      localStorage[mutedKey] = true;
    }

    this.trigger('muted');
  } else {
    this.speaker.setVolume(100);

    if (supports_html5_storage$1()) {
      localStorage[mutedKey] = false;
    }

    this.trigger('unmuted');
  }
};

Player.prototype.getVolume = function () {
  return this.speaker.getVolume();
};

Player.prototype.setVolume = function (vol) {
  this.speaker.setVolume(vol);
};

Player.prototype.getStations = function () {
  return this._stationsPromise;
};

Player.prototype.updateSimulcast = function () {
  var _this7 = this;

  if (!this.state.simulcast) {
    return;
  }

  var state = this.getCurrentState();
  getClientId().then(function (clientId) {
    _this7.session._signedAjax(getBaseUrl() + "/api/v2/simulcast/".concat(_this7.state.simulcast, "/in-progress"), {
      method: 'POST',
      body: JSON.stringify({
        state: state,
        client_id: clientId
      }),
      headers: {
        'Content-Type': 'application/json'
      }
    });
  });
};

function shallowCopy(obj) {
  if (obj === null) {
    return null;
  }

  return Object.assign({}, obj);
}

if (window.NodeList && !NodeList.prototype.forEach) {
  NodeList.prototype.forEach = function (callback, thisArg) {
    thisArg = thisArg || window;

    for (var i = 0; i < this.length; i++) {
      callback.call(thisArg, this[i], i, this);
    }
  };
}

var PlayerView = function PlayerView(id, player) {
  var _this = this;

  this.alertId = null;
  this.durationId = null;
  this.startedPlayback = false;
  this.$el = id instanceof Element ? id : document.getElementById(id);
  this.player = player;
  this.player.on('placement', this._onPlacement, this);
  this.player.on('play-started', this._onPlayStarted, this);
  this.player.on('play-paused', this._onPlayPaused, this);
  this.player.on('play-resumed', this._onPlayResumed, this);
  this.player.on('play-completed', this._onPlayCompleted, this);
  this.player.on('play-stopped', this._onPlayStopped, this);
  this.player.on('play-liked', this._onPlayLiked, this);
  this.player.on('play-unliked', this._onPlayUnliked, this);
  this.player.on('play-disliked', this._onPlayDisliked, this);
  this.player.on('station-changed', this._onStationChanged, this);
  this.player.on('plays-exhausted', this._onPlaysExhausted, this);
  this.player.on('skip-denied', this._onSkipDenied, this);
  this.player.on('suspend', this._onSuspend, this);

  this._enableButtonsBasedOnState();

  this.displayText = this.originalDisplayText = this.$el.querySelector('.status').innerHTML;
  this.renderStatus();
  this.$el.querySelectorAll('.status').forEach(function (status) {
    status.addEventListener('click', _this._onStatusClick.bind(_this));
  });
  this.$el.querySelectorAll('.play-button, .start-button, .resume-button').forEach(function (button) {
    button.addEventListener('click', _this._onPlayButtonClick.bind(_this));
  });
  this.$el.querySelectorAll('.pause-button').forEach(function (pause) {
    pause.addEventListener('click', _this._onPauseButtonClick.bind(_this));
  });
  this.$el.querySelectorAll('.skip-button').forEach(function (skip) {
    skip.addEventListener('click', _this._onSkipButtonClick.bind(_this));
  });
  this.$el.querySelectorAll('.like-button').forEach(function (like) {
    like.addEventListener('click', _this._onLikeButtonClick.bind(_this));
  });
  this.$el.querySelectorAll('.dislike-button').forEach(function (dislike) {
    dislike.addEventListener('click', _this._onDislikeButtonClick.bind(_this));
  });
};

PlayerView.prototype._onStatusClick = function () {
  var state = this.player.getCurrentState();

  if (state === 'playing') {
    this._onPauseButtonClick();
  } else {
    this._onPlayButtonClick();
  }
};

PlayerView.prototype._onPlayButtonClick = function () {
  this.player.initializeAudio();
  this.player.play();
};

PlayerView.prototype._onPauseButtonClick = function () {
  this.player.pause();
};

PlayerView.prototype._onSkipButtonClick = function () {
  this.player.skip();
};

PlayerView.prototype._onLikeButtonClick = function (event) {
  log('like button clicked!', event.target, this);

  if (event.target.classList.contains('liked')) {
    this.player.unlike();
  } else {
    this.player.like();
  }
};

PlayerView.prototype._onDislikeButtonClick = function () {
  this.player.dislike();
};

PlayerView.prototype.$ = function (arg) {
  return this.$el.find(arg);
};

PlayerView.prototype._onPlacement = function (placement) {
  if (!this.originalDisplayText) {
    this.originalDisplayText = this.formatPlacement(placement);
    this.renderStatus(this.originalDisplayText);
  }
};

PlayerView.prototype.formatPlacement = function () {
  return 'Tune in!';
};

PlayerView.prototype._onPlayStarted = function (play) {
  this.startedPlayback = true;
  this.renderStatus(this.formatPlay(play));

  this._enableButtonsBasedOnState();

  this._setLikeStatus(play.liked);

  this._enablePositionTracker();
};

PlayerView.prototype._onStationChanged = function () {
  this._enableButtonsBasedOnState();
};

PlayerView.prototype._enablePositionTracker = function () {
  var playerView = this;

  if (!this.durationId) {
    this.durationId = window.setInterval(function () {
      playerView.renderPosition(playerView.player.getPosition(), playerView.player.getDuration());
    }, 500);
  }
};

PlayerView.prototype._setLikeStatus = function (liked) {
  var likes = this.$el.querySelectorAll('.like-button');
  var dislikes = this.$el.querySelectorAll('.dislike-button');

  if (liked === true) {
    // highlight the like button
    likes.forEach(function (element) {
      element.classList.add('liked');
    });
    dislikes.forEach(function (element) {
      element.classList.remove('disliked');
    });
  } else if (liked === false) {
    // highlight the dislike button
    likes.forEach(function (element) {
      element.classList.remove('liked');
    });
    dislikes.forEach(function (element) {
      element.classList.add('disliked');
    });
  } else {
    // nobody gets highlighted
    likes.forEach(function (element) {
      element.classList.remove('liked');
    });
    dislikes.forEach(function (element) {
      element.classList.remove('disliked');
    });
  }
};

PlayerView.prototype._disablePositionTracker = function () {
  if (this.durationId) {
    window.clearInterval(this.durationId);
    this.durationId = null;
  }
};

PlayerView.prototype._onPlayResumed = function () {
  this._enablePositionTracker();

  this._enableButtonsBasedOnState();
};

PlayerView.prototype._onPlayPaused = function () {
  this._disablePositionTracker();

  this._enableButtonsBasedOnState();
};

PlayerView.prototype._onPlayCompleted = function () {
  this.renderPosition(0, 0);

  this._enableButtonsBasedOnState();
};

PlayerView.prototype._onPlayStopped = function () {
  this.renderStatus(this.originalDisplayText);
  this.renderPosition(0, 0);

  this._enableButtonsBasedOnState();
};

PlayerView.prototype._onPlaysExhausted = function () {
  this.renderStatus(this.originalDisplayText);
  this.renderAlert('There is no more music to play in this station!');

  this._enableButtonsBasedOnState();
};

PlayerView.prototype._onPlayLiked = function () {
  this._setLikeStatus(true);
};

PlayerView.prototype._onPlayDisliked = function () {
  this._setLikeStatus(false);
};

PlayerView.prototype._onPlayUnliked = function () {
  this._setLikeStatus();
};

PlayerView.prototype._onSkipDenied = function () {
  this.renderAlert('Sorry you\'ve temporarily run out of skips!');
};

PlayerView.prototype.formatPlay = function (play) {
  return '<span class=\'track\'>' + play.audio_file.track.title + '</span> by <span class=\'artist\'>' + play.audio_file.artist.name + '</span> on <span class=\'release\'>' + play.audio_file.release.title + '</span>';
};

PlayerView.prototype.renderStatus = function (displayText) {
  var _this2 = this;

  if (displayText !== undefined) {
    this.displayText = displayText;
  }

  if (!this.alertId) {
    this.$el.querySelectorAll('.status').forEach(function (status) {
      status.innerHTML = _this2.displayText;
      status.classList.remove('alert');
    });
  }
};

PlayerView.prototype.renderPosition = function (position, duration) {
  this.$el.querySelectorAll('.elapsed').forEach(function (elapsed) {
    elapsed.innerHTML = formatTime(position);
  });
  this.$el.querySelectorAll('.duration').forEach(function (dur) {
    dur.innerHTML = formatTime(duration);
  });

  if (duration === 0) {
    this.$el.querySelectorAll('.progress').forEach(function (progress) {
      progress.style.width = '0';
    });
  } else {
    var elapsed = Math.round((position + 1000) / duration * 100);
    elapsed = elapsed > 100 ? 100 : elapsed;
    this.$el.querySelectorAll('.progress').forEach(function (progress) {
      progress.style.width = elapsed + '%';
    });
  }
};

function formatTime(millis) {
  var asSeconds = Math.floor(millis / 1000),
      secondsPart = asSeconds % 60,
      minutesPart = Math.floor(asSeconds / 60);

  if (secondsPart < 10) {
    secondsPart = '0' + secondsPart;
  }

  return minutesPart + ':' + secondsPart;
}

PlayerView.prototype.renderAlert = function (alertText) {
  if (this.alertId) {
    window.clearTimeout(this.alertId);
  }

  this.$el.querySelectorAll('.status').forEach(function (status) {
    status.innerHTML = alertText;
    status.classList.add('alert');
  });
  var playerView = this;
  this.alertId = window.setTimeout(function () {
    playerView.alertId = null;
    playerView.renderStatus();
  }, 3000);
};

PlayerView.prototype._onSuspend = function () {
  this._enableButtonsBasedOnState();
};

PlayerView.prototype._enableButtonsBasedOnState = function () {
  var state = this.player.getCurrentState(),
      toEnable,
      toDisable;

  switch (state) {
    case 'playing':
      toEnable = ['.pause-button'];
      toDisable = ['.play-button', '.start-button', '.resume-button'];

      if (this.player.canLike()) {
        toEnable.push('.dislike-button', '.like-button');
      } else {
        toDisable.push('.dislike-button', '.like-button');
      }

      if (this.player.canSkip()) {
        toEnable.push('.skip-button');
      } else {
        toDisable.push('.skip-button');
      }

      break;

    case 'paused':
      toEnable = ['.play-button', '.resume-button'];
      toDisable = ['.pause-button', '.start-button'];

      if (this.player.canLike()) {
        toEnable.push('.dislike-button', '.like-button');
      } else {
        toDisable.push('.dislike-button', '.like-button');
      }

      if (this.player.canSkip()) {
        toEnable.push('.skip-button');
      } else {
        toDisable.push('.skip-button');
      }

      break;

    /* case 'idle': */

    default:
      toEnable = ['.play-button', '.start-button'];
      toDisable = ['.resume-button', '.pause-button', '.like-button', '.dislike-button', '.skip-button'];
      break;
  }

  var _iterator = _createForOfIteratorHelper(toDisable),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var item = _step.value;
      this.$el.querySelectorAll(item).forEach(function (element) {
        element.classList.remove('button-enabled');
        element.classList.add('button-disabled');
        element.disabled = true;
      });
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  var _iterator2 = _createForOfIteratorHelper(toEnable),
      _step2;

  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var _item = _step2.value;
      this.$el.querySelectorAll(_item).forEach(function (element) {
        element.classList.remove('button-disabled');
        element.classList.add('button-enabled');
        element.disabled = false;
      });
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }

  var classes = this.$el.classList;
  classes.remove('state-playing');
  classes.remove('state-paused');
  classes.remove('state-idle');
  classes.add('state-' + state);
};

var METADATA_TIMEOUT = 10000;
var ADVANCE_TIMEOUT = 8000;
/**
 * This class connects to a specific simulcast stream and
 * sends out events to indicate when new songs are starting
 * or when music has stopped playing. This class exposes 
 * 'connect' and 'disconnect' methods to turn on the audio or stop
 * the audio.
 * 
 *   initializeAudio
 *   connect
 *   disconnect
 *   getVolume
 *   setVolume
 * 
 * The player has a state, returned from getCurrentState():
 * 
 *   'idle'       - class hasn't attempted to connect to the stream, or we've
 *                  disconnected from a stream.
 *   'connecting' - we're conneting to the stream (this is set when a
 *                  call to 'connect()' is made)
 *   'connected'  - we have connected to the stream and are playing music (or silence)
 *   'music-unavailable' - no music is available for this client for this stream
 * 
 * The audio volume can be adjusted with setVolume() and retrieved with
 * getVolume().
 * 
 * The player triggers the following events:
 *    play-started - indicates a new song has begun playback, or we've
 *        dropped in on an already playing song. The 'play' that represents
 *        the song is passed as an argument. The 'play' value may be null, 
 *        which indicates silence is playing right now.
 *    music-unavailable - indicates the listener may not listen to music
 *    state-changed - indicates the state of the player changed
 * 
 * Upon a call to 'connect', the client can expect either a 'play-started'
 * event or a 'music-unavailable' event.
 */

var SimulcastPlayer = /*#__PURE__*/function () {
  // var _uuid;     // uuid of stream
  // var _speaker;  // Speaker instance
  // var _streamUrl; // stream we're connecting to
  // var _activePlay; // currently playing song, or null
  // var _activeSound; // if we're playing, this holds the sound
  // var _metadataTimeout; // timeout for retrieving updated metadata
  // var _tryingToPlay = false; // true if we want to play/hear music
  // var _retries; // number of times we've retried playing music
  function SimulcastPlayer(uuid) {
    _classCallCheck(this, SimulcastPlayer);

    Object.assign(this, Events);
    this._speaker = new Speaker();
    this._uuid = uuid;
    this._state = 'idle';
    this._activePlay = null;
    this._activeSound = null;
    this._metadataTimeout = null;
    this._tryingToPlay = false;
    this._retries = 0;
  }

  _createClass(SimulcastPlayer, [{
    key: "initializeAudio",
    value: function initializeAudio() {
      log('INTIALIZE AUDIO');

      this._speaker.initializeAudio();
    }
  }, {
    key: "connect",
    value: function connect() {
      log("CONNECT to ".concat(this._uuid));

      if (this._tryingToPlay) {
        log("ignoring pointless connect to ".concat(this._uuid));
        return;
      }

      if (this._state !== 'idle') {
        log('ignoring connect() since we\'re already connected');
        return;
      }

      this._tryingToPlay = true; // initialize speaker,

      this._speaker.initializeAudio();

      this._setState('connecting'); // this should ask the API server for a URL, really


      var baseApiUrl = new URL(getBaseUrl());
      this._streamUrl = 'https://cast.' + baseApiUrl.hostname + '/' + this._uuid;

      this._requestStream();
    }
  }, {
    key: "_onSoundPlay",
    value: function _onSoundPlay() {
      var _this = this;

      // we've just connected to the stream.
      log('sound play!'); // reset retry count

      this._retries = 0; // starting point to watch for stalls

      this._lastElapsedAt = Date.now();

      if (this._state === 'connecting') {
        this._setState('connected'); // get details about the play


        fetch(this._streamUrl + '/play?elapsed=' + this._elapsed).then(function (res) {
          return res.json();
        }).then(function (res) {
          if (res.success) {
            _this._activePlay = res.play;

            _this.trigger('play-started', _this._activePlay);

            _this._scheduleMetadataTimeout();
          } else {
            // try again in 3 seconds
            _this._scheduleMetadataTimeout(3000);
          }
        }).catch(function () {
          // try again in 2 seconds
          _this._scheduleMetadataTimeout(2000);
        });
      } else if (!this._metadataTimeout) {
        this._scheduleMetadataTimeout();
      }
    }
  }, {
    key: "_scheduleMetadataTimeout",
    value: function _scheduleMetadataTimeout() {
      var _this2 = this;

      var ms = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : METADATA_TIMEOUT;

      this._cancelMetadataTimeout();

      this._metadataTimeout = setTimeout(function () {
        _this2._onMetadataTimeout();
      }, ms);
    }
  }, {
    key: "_cancelMetadataTimeout",
    value: function _cancelMetadataTimeout() {
      if (this._metadataTimeout) {
        clearTimeout(this._metadataTimeout);
      }

      this._metadataTimeout = null;
    }
  }, {
    key: "_onSoundElapse",
    value: function _onSoundElapse() {
      if (this._activeSound) {
        var oldElapsed = this._elapsed;

        var newlyElapsed = this._elapsed = this._activeSound.position();

        if (newlyElapsed - oldElapsed > 0) {
          this._lastElapsedAt = Date.now();
        }
      }
    }
  }, {
    key: "_requestStream",
    value: function _requestStream() {
      log('requesting stream');

      if (!this._tryingToPlay) {
        return;
      }

      if (this._activeSound) {
        this._activeSound.destroy();

        this._activeSound = null;
      } // don't query for metadata while we are trying to stream again


      this._cancelMetadataTimeout();

      this._activePlay = null; // keep retrying until we reconnect (but increase space between retries)

      this._activeSound = this._speaker.create(this._streamUrl, {
        play: this._onSoundPlay.bind(this),
        finish: this._onSoundFinish.bind(this),
        elapse: this._onSoundElapse.bind(this)
      });

      this._activeSound.play();

      this._elapsed = 0;
      this._lastElapsedAt = Date.now();
    }
  }, {
    key: "_onMetadataTimeout",
    value: function _onMetadataTimeout() {
      var _this3 = this;

      this._cancelMetadataTimeout(); // check for update of current song


      fetch(this._streamUrl + '/play?elapsed=' + this._elapsed).then(function (res) {
        return res.json();
      }).then(function (res) {
        if (res.success) {
          if (res.play === null && _this3._activePlay !== null || res.play !== null && _this3._activePlay === null || res.play !== null && _this3._activePlay !== null && res.play.audio_file.id !== _this3._activePlay.audio_file.id) {
            _this3._activePlay = res.play;
            log('current play updated', _this3._activePlay);

            _this3.trigger('play-started', _this3._activePlay);
          }
        }

        _this3._scheduleMetadataTimeout();

        var elapsed = Date.now() - _this3._lastElapsedAt;

        if (elapsed > ADVANCE_TIMEOUT) {
          log("stream has not advanced for ".concat(elapsed, " ms, so reconnecting"), _this3.toObject()); // reconnect if we've been down for a while

          _this3._requestStream();
        }
      }).catch(function () {
        var elapsed = Date.now() - _this3._lastElapsedAt;

        if (elapsed > ADVANCE_TIMEOUT) {
          log("stream has not advanced for ".concat(elapsed, " ms, so reconnecting"), _this3.toObject()); // reconnect if we've been down for a while

          _this3._requestStream();
        } else {
          _this3._scheduleMetadataTimeout();
        }
      });
    }
  }, {
    key: "_onSoundFinish",
    value: function _onSoundFinish(error) {
      var _this4 = this;

      log('sound finished', this.toObject());

      if (this._state === 'connecting' && error) {
        // we weren't granted access to stream
        this._tryingToPlay = false;

        this._setState('music-unavailable');

        this.trigger('music-unavailable');
      } else {
        log('reconnecting after stream ended', error); // we must have lost the stream during playback. try
        // reconnecting. 

        if (this._activeSound) {
          this._activeSound.destroy();

          this._activeSound = null;
        } // don't query for metadata while we are trying to stream again


        this._cancelMetadataTimeout();

        this._activePlay = null; // keep retrying until we reconnect (but increase space between retries)

        this._retries += 1;
        setTimeout(function () {
          if (_this4._tryingToPlay) {
            log('retrying connection after stream ended');

            _this4._requestStream();
          }
        }, Math.pow(2, this._retries));
      } // help us narrow down streaming issues


      this._logEvents();
    }
  }, {
    key: "disconnect",
    value: function disconnect() {
      log('DISCONNECT', this.toObject());

      if (!this._tryingToPlay) {
        return;
      }

      this._tryingToPlay = false;
      this._activePlay = null;
      this._elapsed = 0;

      this._cancelMetadataTimeout(); // stop and destroy our sound object


      if (this._activeSound) {
        this._activeSound.destroy();

        this._activeSound = null;
      }

      this._setState('idle');

      this._logEvents();
    }
  }, {
    key: "getVolume",
    value: function getVolume() {
      return this._speaker.getVolume();
    }
  }, {
    key: "setVolume",
    value: function setVolume(vol) {
      this._speaker.setVolume(vol);
    }
  }, {
    key: "_setState",
    value: function _setState(newState) {
      if (this._state !== newState) {
        log("state transition ".concat(this._state, " -> ").concat(newState));
        this._state = newState;
        this.trigger('state-changed', this._state);
      }
    }
  }, {
    key: "getCurrentState",
    value: function getCurrentState() {
      return this._state;
    }
  }, {
    key: "getCurrentPlay",
    value: function getCurrentPlay() {
      return this._activePlay;
    }
  }, {
    key: "_logEvents",
    value: function _logEvents() {
      var history = log.reset();
      return fetch(getBaseUrl() + '/api/v2/session/event', {
        method: 'POST',
        body: JSON.stringify({
          event: 'playerHistory',
          parameters: history
        }),
        headers: {
          'Content-Type': 'application/json',
          'X-Feed-SDK': version + ' js'
        }
      });
    }
  }, {
    key: "toObject",
    value: function toObject() {
      return {
        state: this._state,
        activePlay: this._activePlay,
        uuid: this._uuid,
        metadataTimeoutIsNull: this._metadataTimeout === null,
        tryingToPlay: this._tryingToPlay,
        elapsed: this._elapsed,
        retries: this._retries
      };
    }
  }, {
    key: "toString",
    value: function toString() {
      return JSON.stringify(this.toString());
    }
  }]);

  return SimulcastPlayer;
}();

/**
 * This method checks local storage to see if a Player instance was playing
 * music within the given number of milliseconds. If not, null is returned.
 * If so, a new Player instance is created and returned, but the `tune()`
 * method is swapped out so that, after calling `tune()` the player will 
 * transition into a `paused` state. When `play()` is called, the player
 * will begin playback from the last position of the song the player
 * was previously playing.
 **/

function resumable() {
  var maxMilliseconds = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 4000;
  var state = retrieveStateAndElapsed(maxMilliseconds);

  if (state.length === 2) {
    var _state = _slicedToArray(state, 2),
        persisted = _state[0],
        elapsed = _state[1];

    var player = new Player({
      persisted: persisted,
      elapsed: elapsed
    });
    return player;
  }

  return null;
}

var index = {
  Speaker: Speaker,
  Session: Session,
  Player: Player,
  Listener: Listener,
  PlayerView: PlayerView,
  SimulcastPlayer: SimulcastPlayer,
  log: log,
  version: version,
  resetClientId: deleteClientId,
  getClientId: getClientId,
  setBaseUrl: setBaseUrl,
  resumable: resumable
};

module.exports = index;
